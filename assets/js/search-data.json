{
  
    
        "post0": {
            "title": "SOLID principles in Java",
            "content": "SOLID principles code translation in Java . Published by Saman Pordanesh . Introduction . SOLID is an acronym for the first five object-oriented design (OOD) principles. These principles establish practices that lend to developing software with considerations for maintaining and extending as the project grows. Adopting these practices can also contribute to avoiding code smells, refactoring code, and Agile or Adaptive software development. SOLID stands for: S - Single-responsiblity Principle O - Open-closed Principle L - Liskov Substitution Principle I - Interface Segregation Principle D - Dependency Inversion Principle | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better. | This translation is based on the final code source of Solid Principles lessons in python programming languages (dependency-inversion-after.py) | We need a separate class with the main function to run the program, despite Python, which you can each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.solid (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/solid/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.solid.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . Order . Python version . class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = &quot;open&quot; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total . Java version . package edu.def.solid; public class Order { private String[] items; private int[] quantities; private int[] prices; private String status = &quot;open&quot;; int numberOfItems = 0; Order(int numberOfItems){ items = new String[numberOfItems]; quantities = new int[numberOfItems]; prices = new int[numberOfItems]; } public void addItem(String name, int quantity, int price){ this.items[numberOfItems] = name; this.quantities[numberOfItems] = quantity; this.prices[numberOfItems] = price; numberOfItems++; } public int totalPrice(){ int total = 0; for (int i = 0; i &lt; numberOfItems; i++){ total += this.quantities[i] * this.prices[i]; } return total; } public void setStatus(String status) { this.status = status; } public String getStatus() { return status; } } . In this class, we need to clarify each array’s size as a Java programming rule. We can do it at the initializer by passing the number of items on the class constructor. | We implemented all variables (items, quantities, …) as class attributes on Java with private visibility to protect them from direct access out of the class. Also, status has a default value of “open”. | A variable like numberOfItems is needed to keep track of the arrays and access them later, as Java doesn’t automatically detect where should add a new item in the array (nothing like append in python). In addition, we should keep updating this variable by adding every single item (in the addItem function). | getters and setters for each private parameter, are not required; You can access fields directly by making parameters public in Java as well, but it’s (private parameters) frequently done in Java as an OOP principle. We followed that principle here and as we will need to access status in other classes, we defined getter and setter for this class’s parameter. | Authorizer . Python version . class Authorizer(ABC): @abstractmethod def is_authorized(self) -&gt; bool: pass . Java version . package edu.def.solid; public interface Authorizer { public boolean isAuthorized(); } . This class was an abstract class on the python version. Abstracts are usually used when we want to implement a specific function with all its functionalities that all children will use in the future. But when we need only the prototype (function naming, return type and arguments only), which will be implemented by each child later, we use interfaces in Java programming. As a result, we implement the Authorizer class as an interface class containing the isAuthotized function prototype. . | A class in Java can inherit an interface by the “implements” keyword after the class name. . | public class AuthorizerSMS implements Authorizer{ ... . Also, all interface methods should be overridden in this child class (implement them completely) . @Override public boolean isAuthorized() { return this.authorized; } . AuthorizerSMS . Python version . class Authorizer_SMS(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f&quot;Verifying SMS code {code}&quot;) self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerSMS implements Authorizer{ private boolean authorized = false; public void verifyCode(int code){ System.out.print(&quot;Verifying SMS code &quot; + code); this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . We defined the variable authorized as a private class attribute. | The isAuthorized method was overridden based on its interface, inheriting that (Authorizer). . | At the verifyCode method, we appended the variable to the printed text by the “+**” sign, although in python, a formatting printing method was used (the **f char at the start of the string) | AuthorizerGoogle . Python version . class Authorizer_Google(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f&quot;Verifying Google auth code {code}&quot;) self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerGoogle implements Authorizer { private boolean authorized = false; public void verifyCode(int code){ System.out.print(&quot;Verifying Google code &quot; + code); this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . The same points as AuthorizerSMS . AuthorizerRobot . Python version . class Authorizer_Robot(Authorizer): def __init__(self): self.authorized = False def not_a_robot(self): self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerRobot implements Authorizer { private boolean authorized = false; public void notARobot(){ this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . The same points as AuthorizerSMS . PaymentProcessor . Python version . class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass . Java version . package edu.def.solid; public interface PaymentProcessor { public void pay(Order order) throws Exception; } . this class is an interface and acts the same as the Authorizer class. This is an interface which imposes the implementation of a specific method on each child, which will be inherent in this interface. | In addition, be careful that the order argument in the payment method is in the type of Order class. (We call it non-primitive data type) | We have an Exception method under a specific condition in the python. In Java, we must specify the “throws Exception” keyword on the function’s prototype and interface. | DebitPaymentProcessor . Python version . class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: Authorizer): self.security_code = security_code self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(&quot;Not authorized&quot;) print(&quot;Processing debit payment type&quot;) print(f&quot;Verifying security code: {self.security_code}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class DebitPaymentProcessor implements PaymentProcessor{ private int securityCode; private Authorizer authorizer; DebitPaymentProcessor(int securityCode, Authorizer authorizer){ this.securityCode = securityCode; this.authorizer = authorizer; } @Override public void pay(Order order) throws Exception { if (!authorizer.isAuthorized()){ throw new Exception(&quot;Not authorized&quot;); } System.out.println(&quot;Processing debit payment type&quot;); System.out.println(&quot;Verifying security code: &quot; + this.securityCode); order.setStatus(&quot;paid&quot;); } } . We have a constructor to specify two-class parameter values, securitycode and authorizer. Notice that authorizer is a non-primitive data type in the type of Authorizer. | We specified all parameters as private because of the Java OOP rules and without getter and setter, as they are being used only for internal purposes. | The pay method is an overridden method from the PaymentProcessor interface. It shows us that this class inherits the PaymentProcessor interface. | The pay method in this class throws an exception, so we need “throws Exception” keyword at the method’s prototype. | CreditPaymentProcessor . Python version . class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(&quot;Processing credit payment type&quot;) print(f&quot;Verifying security code: {self.security_code}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class CreditPaymentProcessor implements PaymentProcessor { private int securityCode; CreditPaymentProcessor(int securityCode){ this.securityCode = securityCode; } @Override public void pay(Order order){ System.out.println(&quot;Processing credit payment type&quot;); System.out.println(&quot;Verifying security code: &quot; + this.securityCode); order.setStatus(&quot;paid&quot;); } } . The same points of debitPaymentProcessor will apply for this class, except we don’t have the authorizer parameter and any exceptions for the pay method. . PaypalPaymentProcessor . Python version . class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address, authorizer: Authorizer): self.email_address = email_address self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(&quot;Not authorized&quot;) print(&quot;Processing paypal payment type&quot;) print(f&quot;Using email address: {self.email_address}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class PaypalPaymentProcessor implements PaymentProcessor{ private String emailAddress; private Authorizer authorizer; PaypalPaymentProcessor(String emailAddress, Authorizer authorizer){ this.emailAddress = emailAddress; this.authorizer = authorizer; } @Override public void pay(Order order) throws Exception { if (!authorizer.isAuthorized()){ throw new Exception(&quot;Not authorized&quot;); } System.out.println(&quot;Processing paypal payment type&quot;); System.out.println(&quot;Using email address: &quot; + this.emailAddress); order.setStatus(&quot;paid&quot;); } } . The same points of debitPaymentProcessor will apply to this class. Only some changes about authentication and change from security code to email verification. .",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/9-SolidPrinciples.html",
            "relUrl": "/markdown/2022/06/19/9-SolidPrinciples.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "MVC in Java",
            "content": "MVC (Model-View-Controller) code translation in Java . Published by Saman Pordanesh . General Introduction . MVC (Model-View-Controller) is a pattern in software design commonly used to implement user interfaces, data, and controlling logic. It emphasizes the separation between the software’s business logic and display. For more, click here. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of the MVC lessons in python programming languages (mvc-after-strategy.py). | Point: This translation is much more different from the original Python version’s structure, libraries, and functionalities in this Java version. It’s caused as we have two different libraries for UI (user interface) in Python and Java, which follow different structures. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on Java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with the same directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.mvc (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. In addition, we have a sub package edu.def.mvc.uuid for the UUID interface and its children, as far as the strategy is concerned. (Have different strategies for generating different UUIDs) | However, packages are unnecessary; you could use a default package or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.mvc package. They can be interfaces and child classes or simple classes. In addition, in this lesson, we have a sub-package “edu.def.mvc.uuid” in a separate folder on the main package directory to hold a class category that behaves similarly. Learn more about sub-packages here. | In this project, we use Java GUI libraries AWT and Swing, which have a different structure and functionality than Python’s Tkinter library for the same purpose. E.g., we don’t need a loop in the Java version to run the UI, although we need it in the Python version. Complete tutorial about Java GUI with Swing here. | We have three MVC classes: Model.java, Controller.java and View.java**. In addition, we have a class called **SwingView.java, which implements View.java and handle all user interface codes. From that class, we combine all MVC principles to run an application. Finally, the interface GenerateUuid.java and its children Uuid.java, Uuid4.java and UuidString.java are classes to generate different UUIDs, depending on which one we choose on the main () method. | Main.java contains our main () method to run the program. | Note that all steps here are entirely for the best OOP practice in Java programming; They can be done more straightforwardly, but not the best OOP ways. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/mvc/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.mvc.Main . | If your main function is in a different class, but the name of that class instead of Main at the end of the command | You can find more about compiling instructions here. | . Classes changes . Model . Python version . class Model: def __init__(self): self.uuid = [] . Java version . package edu.def.mvc; import java.util.ArrayList; import java.util.UUID; /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ /** * This is the Model class which should act as a database in this program. * This model is pretty simple, and we can hold the whole data on a simple ArrayList. * In complicated versions, Model class should connect with an external database. */ public class Model { private ArrayList&lt;UUID&gt; uuids; Model(){ uuids = new ArrayList&lt;&gt;(); } public void setUuids(ArrayList&lt;UUID&gt; uuids) { this.uuids = uuids; } public ArrayList&lt;UUID&gt; getUuids() { return uuids; } public void addUuid(UUID uuid){ this.uuids.add(uuid); } public void clearModel(){ this.uuids.clear(); } } . This class required an ArrayList to act as a data holder. We will keep all generated UUIDs in this ArrayList and use them through the program. | As the ArrayList is a private parameter and we need access to it in other classes, we have getter and setter methods for this purpose. In addition, addUuid () is used to add a generated UUID to the model and clearModel () is used to clear the whole model when needed. However, by making the ArrayList a public parameter, we won’t need getter, setter, add and clean functions, but all of them are for best OOP practices. | Controller . Python version . class Controller: def __init__(self, model, view, generate_uuid): self.model = model self.view = view self.generate_uuid = generate_uuid def start(self): self.view.setup(self) self.view.start_main_loop() def handle_click_generate_uuid(self): # generate a uuid and add it to the list self.model.uuid.append(self.generate_uuid()) self.view.append_to_list(self.model.uuid[-1]) def handle_click_clear_list(self): # clear the uuid list in the model and the view self.model.uuid = [] self.view.clear_list() . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import edu.def.mvc.uuid.GenerateUuid; import java.util.UUID; /** * Controller class */ public class Controller { private Model model; private View view; private GenerateUuid generateUuid; Controller(Model model, View view, GenerateUuid uuid){ this.model = model; this.view = view; this.generateUuid = uuid; } //start the initial UI public void start(){ this.view.setup(this); } //handle &quot;Generate UUID&quot; button and public void handleClickGenerateUuid(){ this.model.addUuid(this.generateUuid.generateUuid()); } //handle &quot;Clear list&quot; button and public void handleClickClearList(){ this.model.clearModel(); this.view.clearList(); } //getting the Model object to use its data public Model getModel() { return model; } } . This class controls all actions in the program and acts as a connector between View and Model as well (as you can see, we have both View and Model objects as parameters of this class). | We have a parameter of the GeneratedUuid interface. We pass the GeneratedUuid children to the Controller class by its constructor to define which kind of UUID we want to generate in the application. | In the start () method, we call the setup () method of the View object to start GUI’s engine. | The following method is handleClickGenerateUuid () when the user clicks on the “Generate UUID” button. This method should generate a UUID by generateUuid object and adding it to the model. | The method handleClickClearList () handles the functionality of the “Clear List” button and clears the model entirely. | View . Python version . class View(ABC): @abstractmethod def setup(self, controller): pass @abstractmethod def append_to_list(self, item): pass @abstractmethod def clear_list(self): pass @abstractmethod def start_main_loop(self): pass . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import javax.swing.*; import java.util.UUID; public abstract class View { public abstract void setup(Controller controller); public abstract void appendToList(UUID item); public abstract void clearList(); public abstract void startMainLoop(); } . This class is an abstract with four methods to handle the view of the application. | The setup () method will use to contain and start a GUI engine. | The method appendToList () is a method to run and handle the “Generate UUID” button view on the application. | Also, the method clearList () is a method to run and handle the “Clear List” button view on the application. | Finally, startMainLoop() contains a method to make the frame visible. Unlike Python, in the Java version of GUI, we don’t need a loop to run the application. | SwingView (as TkView in the Python version) . Python version . class TkView(View): def setup(self, controller): # setup tkinter self.root = tk.Tk() self.root.geometry(&quot;400x400&quot;) self.root.title(&quot;UUIDGen&quot;) # create the gui self.frame = tk.Frame(self.root) self.frame.pack(fill=tk.BOTH, expand=1) self.label = tk.Label(self.frame, text=&quot;Result:&quot;) self.label.pack() self.list = tk.Listbox(self.frame) self.list.pack(fill=tk.BOTH, expand=1) self.generate_uuid_button = tk.Button(self.frame, text=&quot;Generate UUID&quot;, command=controller.handle_click_generate_uuid) self.generate_uuid_button.pack() self.clear_button = tk.Button(self.frame, text=&quot;Clear list&quot;, command=controller.handle_click_clear_list) self.clear_button.pack() def append_to_list(self, item): self.list.insert(tk.END, item) def clear_list(self): self.list.delete(0, tk.END) def start_main_loop(self): # start the loop self.root.mainloop() . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.UUID; /** * this class handles all three MVC classes to generate a UI application. * It uses Swing &amp; AWT libraries for generating GUI. */ class SwingView extends View implements ActionListener { JFrame frame; TextArea display; JButton createButton; JButton clearButton; Controller controller; @Override public void setup(Controller controller) { // A controller object to control all principles in the program // from a unique class. this.controller = controller; this.frame = new JFrame(); // Create a list for holding all generated uuids // responsive to add and clear by two &quot;generateButton&quot; and // &quot;clearButton&quot; buttons. this.display = new TextArea(&quot;&quot;, 20, 80); this.display.setEditable(false); this.startMainLoop(); // Create two button for generating uuid and append to the list (generateButton) // and clear the least (clearButton) this.createButton = new JButton(&quot;Generate UUID&quot;); this.createButton.addActionListener(this); this.clearButton = new JButton(&quot;Clear List&quot;); this.clearButton.addActionListener(this); JPanel buttonPanel = new JPanel(); buttonPanel.setLayout(new GridLayout(0,2)); buttonPanel.add(this.createButton); buttonPanel.add(this.clearButton); Container content = this.frame.getContentPane(); content.setLayout(new BorderLayout()); content.add(&quot;Center&quot;, this.display); content.add(&quot;South&quot;, buttonPanel); this.frame.setPreferredSize(new Dimension(300, 200)); this.frame.setTitle(&quot;UUID generator&quot;); this.frame.pack(); } @Override public void appendToList(UUID item) { this.display.append(item.toString() + &quot; n&quot;); } @Override public void clearList() { this.display.setText(&quot;&quot;); } @Override public void startMainLoop() { this.frame.setVisible(true); } @Override public void actionPerformed(ActionEvent e) { if(e.getSource() == this.createButton) { this.controller.handleClickGenerateUuid(); Model model = controller.getModel(); this.appendToList(model.getUuids().get(model.getUuids().size()-1)); }else if (e.getSource() == this.clearButton) { this.controller.handleClickClearList(); this.clearList(); } } } . Java’s GUI and Swing library principles are out of this course’s scope. We recommend reading more about Swing library. Also, this and this video may help you to understand better. | As we said, this class inherits the View abstract. As a result, we need to override all methods of that abstract in this child class. | GenerateUuid (plus all three children who are inheriting this interface) . Python version . # functional strategy def generate_uuid1(): return uuid.uuid1() def generate_uuid4(): return uuid.uuid4() def generate_simple_id(): return &#39;&#39;.join(random.choices(string.ascii_lowercase, k=30)) class Model: def __init__(self): self.uuid = [] . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc.uuid; import java.util.UUID; /** * Interface for all UUIDs generators classes. * Only contains one method for generating a kind of UUIDs. */ public interface GenerateUuid { public UUID generateUuid(); } . //For UUID1 public class Uuid1 implements GenerateUuid{ @Override public UUID generateUuid() { byte[] byteName = { 50, 40, 30, 20, 10 }; return UUID.nameUUIDFromBytes(byteName); } } . //For UUID4 public class Uuid4 implements GenerateUuid{ @Override public UUID generateUuid() { return UUID.randomUUID(); } } . //For UUIDString public class UuidString implements GenerateUuid{ @Override public UUID generateUuid() { return UUID.fromString(&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d&quot;); } } . This interface and its children under a sub package were substituted for three functions in Python language, which are responsible for generating different UUIDs. While this structure could be much simpler without any interface, inheritance, or sub-package, we are following OOP principles for the best practice. | This interface has one method that will be overridden through different child classes. | The generateUuid () method generates different kinds of UUID, which the Java programming language allows us to generate. | We created three other classes based on this interface which are Uuid1.java, Uuid4.java and UuidString.java**, and each of them will generate a different **UUID string. | To generate those UUIDs, we used a native Java library called “java.util.UUID”. We highly recommend reading about it here. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/8-MVC.html",
            "relUrl": "/markdown/2022/06/19/8-MVC.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Template Method & Bridge in Java",
            "content": "Template Method &amp; Bridge code translation in Java . Published by Saman Pordanesh . General Introduction . The Template Method design pattern is to define an algorithm as a skeleton of operations and leave the details to be implemented by the child classes. The parent class preserves the overall structure and sequence of the algorithm. Also, In computer science, bridging describes systems that map the runtime behaviour of different programming languages so they can share common resources. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of the Template method and Bridge lessons in python programming languages (with-bridge.py). That is the complete file, which contains all principles such as Abstraction, Inheritance, etc. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on Java is different. You can find more information here. | There is a UML.png file in this repository’s folder, which shows relationships between different classes. Please check it as a good reference for understanding this code. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with the same directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.tmab (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are unnecessary; you could use a default package or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.tmab package. They can be interfaces, abstractions, child classes or simple classes. | After that, we will translate all classes to their belonging files based on the Python source. We will compare them with the original version in the following section. | This article will introduce the Abstract class and method. The abstract is a kind of parent class with both methods and parameters. Methods can be in two different categories; Abstract methods are those that we implement in the abstract class, and all children will inherit them the same as the parent. The other kind of method is just a prototype that shows the return type, name and arguments needed. Still, we will implement the content of the method on each child individually using the override keyword. We implement an abstract class by using the “abstract” keyword at the start of the class definition. | Main.java contains our main() method to run the program. | Note that all steps here are entirely for the best OOP practice in Java programming; They can be done more straightforwardly, but not the best OOP ways. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/tmab/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.tmab.Main . | If your main function is in a different class, but the name of that class instead of Main at the end of the command | You can find more about compiling instructions here. | . Classes changes . Exchange . Python version . class Exchange(ABC): @abstractmethod def connect(self): pass @abstractmethod def get_market_data(self, coin: str) -&gt; List[float]: pass . Java version . package edu.def.tmab; import java.util.ArrayList; public interface Exchange { public void connect(); public ArrayList&lt;Float&gt; getMarketData(String coin); } . This class is defined as an interface class, although it was described as an abstract one on the Python version. The reason is that we don’t have an interface class specifically on Python programming languages. Please read about the differences between interface and abstract class. | In this class, we define the prototype of each method that a child will inherit. Then, we will override it at the child class later. | Binance . Python version . class Binance(Exchange): def connect(self): print(f&quot;Connecting to Binance exchange...&quot;) def get_market_data(self, coin: str) -&gt; List[float]: return [10, 12, 18, 14] . Java version . package edu.def.tmab; import java.util.ArrayList; public class Binance implements Exchange{ @Override public void connect() { System.out.println(&quot;Connecting to Binance exchange...&quot;); } @Override public ArrayList&lt;Float&gt; getMarketData(String coin) { return new ArrayList&lt;&gt;(); } } . This is a child class which inherits the interface Exchange. As you can see, we override both interface methods in this class. Also, we don’t have any limitations to adding more parameters and methods in this class beyond the inherited interface. | In the getMarketData() method, we initialized the ArrayList by some numbers differently from Python. This is the proper way to do that In Java. You can find more here. (“f” in front of each number means “float” data type) | Coinbase . Python version . class Coinbase(Exchange): def connect(self): print(f&quot;Connecting to Coinbase exchange...&quot;) def get_market_data(self, coin: str) -&gt; List[float]: return [10, 12, 18, 20] . Java version . package edu.def.tmab; import java.util.ArrayList; public class Coinbase implements Exchange{ @Override public void connect() { System.out.println(&quot;Connecting to Binance exchange...&quot;); } @Override public ArrayList&lt;Float&gt; getMarketData(String coin) { return new ArrayList&lt;&gt;(); } } . The same point as the Binance class. . TradingBot . Python version . class TradingBot(ABC): def __init__(self, exchange: Exchange): self.exchange = exchange def check_prices(self, coin: str): self.exchange.connect() prices = self.exchange.get_market_data(coin) should_buy = self.should_buy(prices) should_sell = self.should_sell(prices) if should_buy: print(f&quot;You should buy {coin}!&quot;) elif should_sell: print(f&quot;You should sell {coin}!&quot;) else: print(f&quot;No action needed for {coin}.&quot;) @abstractmethod def should_buy(self, prices: List[float]) -&gt; bool: pass @abstractmethod def should_sell(self, prices: List[float]) -&gt; bool: pass . Java version . package edu.def.tmab; import java.util.ArrayList; public abstract class TradingBot { private Exchange exchange; TradingBot(Exchange exchange){ this.exchange = exchange; } public void checkPrices(String coin){ this.exchange.connect(); ArrayList&lt;Float&gt; prices = this.exchange.getMarketData(coin); boolean shouldBuy = this.shouldBuy(prices); boolean shouldSell = this.shouldSell(prices); if (shouldBuy){ System.out.println(&quot;You should buy &quot; + coin + &quot;!&quot;); } else if (shouldSell) { System.out.println(&quot;You should sell &quot; + coin + &quot;!&quot;); } else { System.out.println(&quot;No action needed for &quot; + coin + &quot;.&quot;); } } public abstract boolean shouldBuy(ArrayList&lt;Float&gt; prices); public abstract boolean shouldSell(ArrayList&lt;Float&gt; prices); } . This class is an Abstract class, as we discussed at Implementation Instruction. You can see the “abstract” keyword in the class implementation, which is necessary for implementation. | As you can see, we have both implemented method and abstract method (only prototype) methods in this class. We will override all abstract methods for the children who will inherit from. In terms of the implemented method, all children will inherit them precisely with the same functionality we defined for the method in the abstraction class. We won’t override them later. | checkPrices() is a local method, but shouldBuy() and shouldSell() are abstract methods. | As we said before, an abstract class acts like a regular class and can have local methods, parameters, a constructor, and abstract methods. | AverageTrader . Python version . class AverageTrader(TradingBot): def list_average(self, l: List[float]) -&gt; float: return sum(l) / len(l) def should_buy(self, prices: List[float]) -&gt; bool: return prices[-1] &lt; self.list_average(prices) def should_sell(self, prices: List[float]) -&gt; bool: return prices[-1] &gt; self.list_average(prices) . Java version . package edu.def.tmab; import java.util.ArrayList; public class AverageTrader extends TradingBot{ /** * in java, when a class inherits an abstraction parent, we should have the constructor for the parent on the child class as well. The keyword for it is &quot;super&quot;. * @param exchange */ AverageTrader(Exchange exchange) { super(exchange); } public float listAverage(ArrayList&lt;Float&gt; list){ //we don&#39;t have any function to calculate sum of the // item on a list automatically. float sum = 0; for (float item: list){ sum += item; } return sum/list.size(); } @Override public boolean shouldBuy(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. return prices.get(prices.size() - 1) &lt; this.listAverage(prices); } @Override public boolean shouldSell(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. return prices.get(prices.size() - 1) &gt; this.listAverage(prices); } } . This child inherits the TradingBot abstraction class through the “extends” keyword. | The critical point is that we should first feed the parent’s constructor from this class’s constructor. It can be done by a super() method which takes arguments if the parent’s constructor needs any. You can find out more here. Also, we can initialize more parameters in this constructor if the class has any local ones. | As it is clear, we have two overridden methods, shouldBuy() and shouldSell() , which are abstract methods that belong to the abstract parent. In addition, we have a local method listAverage() . | MinMaxTrader . Python version . class MinMaxTrader(TradingBot): def should_buy(self, prices: List[float]) -&gt; bool: return prices[-1] == min(prices) def should_sell(self, prices: List[float]) -&gt; bool: return prices[-1] == max(prices) . Java version . package edu.def.tmab; import java.util.ArrayList; import java.util.Collections; import java.util.Objects; public class MinMaxTrader extends TradingBot{ /** * in java, when a class inherits an abstraction parent, we should have the constructor for the parent on the child class as well. The keyword for it is &quot;super&quot;. * @param exchange */ MinMaxTrader(Exchange exchange) { super(exchange); } @Override public boolean shouldBuy(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. //Also, Collections.min() will find the maximum item in a list return Objects.equals(prices.get(prices.size() - 1), Collections.min(prices)); } @Override public boolean shouldSell(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. //Also, Collections.max() will find the maximum item in a list. return prices.get(prices.size() - 1) == Collections.max(prices); } } . The same points as AverageTrader class. .",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/6-TemplateMethodAndBridge.html",
            "relUrl": "/markdown/2022/06/19/6-TemplateMethodAndBridge.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "The Strategy Pattern in Java",
            "content": "The Strategy Pattern code translation in Java . Published by Saman Pordanesh . General Introduction . Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Strategy Pattern lessons in python programming languages (strategy-after.py) Point: This part was done in two different (oop &amp; functional) methods. This translation is based on the oop method, and we didn’t translate the functional one, as that method doesn’t work in Java very well, although in Python may work well. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project by an exact directory with all dependencies can be a good practce OOP designing. | We defined a package name for this project as edu.def.sp (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.sp package. | As we have different ordering methods, we’ll define one class per each ordering way. They all inherit an interface (TicketOrderingStrategy.java) that contains only one ordering method (createOrdering.java). | As mentioned, one class for each ordering method is needed, which will be: FIFOOrderingStrategy.java – FILOOrderingStrategy.java - RandomOrderingStrategy.java – BlackHoleStrategy.java . | When creating other classes (SuportTicket.java &amp; CustomSupport.java), we need Main.java to contain our main function to run the program. | After that, we will translate all classes to their belonging files based on the Python source. We will compare them with the original version in the following section. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/sp/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.sp.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . SupportTicket . Python version . class SupportTicket: def __init__(self, customer, issue): self.id = generate_id() self.customer = customer self.issue = issue def generate_id(length=8): # helper function for generating an id return &#39;&#39;.join(random.choices(string.ascii_uppercase, k=length)) . Java version . package edu.def.sp; import java.util.Random; public class SupportTicket { private String id; private String customer; private String issue; SupportTicket(String customer, String issue){ this.id = getSaltString(&quot;uppercase&quot;, 8); this.customer = customer; this.issue = issue; } public String getId() { return id; } public String getCustomer() { return customer; } public String getIssue() { return issue; } /** * As we dont have a simple function to arrange a random string on Java, we are implementing * this helper method to help us create one. * It acts like &quot;random.choices&quot; in Python * @param ascii * @return */ private String getSaltString(String ascii, int length) { //char sets based on the incoming argument String SALTCHARS; switch (ascii){ case &quot;uppercase&quot;: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; break; case &quot;lowercase&quot;: SALTCHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;; break; case &quot;digits&quot;: SALTCHARS = &quot;1234567890&quot;; break; default: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; } StringBuilder salt = new StringBuilder(); Random rnd = new Random(); while (salt.length() &lt; length) { // length of the random string. int index = (int) (rnd.nextFloat() * SALTCHARS.length()); salt.append(SALTCHARS.charAt(index)); } return salt.toString(); } } . This is a class for creating tickets with three parameters id, customer, issue, and three getters for each parameter. As we are defining the parameter values on the constructor and won’t need to change them separately later, we don’t have a setter method for any parameter. Aslo, we can access parameters directly by making them public, but we use private parameters as an OOP designing principle. | The constructor received two arguments for customer and issue, but Id will be valued by generating a random string generator. | The only private method used to generate a random string with a specified size (we need to define this function as we don’t have any predefined method to do that in Java, although Python has). | TicketOrderingStrategy . Python version . class TicketOrderingStrategy(ABC): @abstractmethod def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: pass . Java version . package edu.def.sp; import java.util.ArrayList; public interface TicketOrderingStrategy { /** * A function which receives a list and return another list based on the ordering type. * @param list: an argument of ArrayList data type which contains SupportTicket objects * @return: the same data type of incoming argument, but with different ordering */ public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list); } . This is the interface we discussed at instruction, which all other ordering classes will inherit. We will override this interface’s createOrdering() method in all those classes. | As we can see, the creatingOrdering() method’s prototype defines which arguments are needed for this method and what will be its return value data type. | FIFOOrderingStrategy . Python version . class FIFOOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: return list.copy() . Java version . package edu.def.sp; import java.util.ArrayList; public class FIFOOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { return (ArrayList&lt;SupportTicket&gt;) list.clone(); } } . This class is one of the ordering ways classes implemented(inherited) from the TicketSupportingStrategy interface. | We have overridden the interface’s method as our desire for this class of ordering. | The list is already in order in this ordering method (first in, first out) der. You need to return it by creating a copy through the clone method. | Clone: clone() is a method to deeply copy an object in Java programming languages. When we use the “=” sign to copy an object, we are putting the address of the source (obj1) object to the destination (obj2); this means that if we change the boj1’s value, obj2’s value will be adjusted consequently. But with the clone() method, we can create an independent copy of obj1 and assign it to the obj2, although still, we can do more about making a completely separate copy, which is out of the scope of this article. Please click here for more. | FILOOrderingStrategy . Python version . class FILOOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: list_copy = list.copy() list_copy.reverse() return list_copy . Java version . package edu.def.sp; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; public class FILOOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { //clone() reates a partial deep copy of the object ArrayList&lt;SupportTicket&gt; listCopy = (ArrayList&lt;SupportTicket&gt;) list.clone(); //a function to reverse an ArrayList Collections.reverse(listCopy); return listCopy; } } . Most of the FIFOOrderingStrategy’s points are applicable here. . In this ordering class, after making a copy of the list by clone, we should reverse the list because of our ordering way (first in, last out). We did it using the Collection class and its method reverse(), which reversed the list and returned it. | RandomOrderingStrategy . Python version . class RandomOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: list_copy = list.copy() random.shuffle(list_copy) return list_copy . Java version . package edu.def.sp; import java.util.ArrayList; import java.util.Collections; public class RandomOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { ArrayList&lt;SupportTicket&gt; listCopy = (ArrayList&lt;SupportTicket&gt;) list.clone(); //shuffle the list randomly Collections.shuffle(listCopy); return listCopy; } } . Most of the FIFOOrderingStrategy’s points are applicable here. . In this ordering class, after making a copy of the list by clone, we should shuffle the list because of our ordering way (random). We did it using a class called Collection and its method shuffle(), which shuffled the list and returned it. | BlackHoleStrategy . Python version . class BlackHoleStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: return [] . Java version . package edu.def.sp; import java.util.ArrayList; public class BlackHoleStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { //just return an empty ArrayList return new ArrayList&lt;&gt;(); } } . Most of the FIFOOrderingStrategy’s points are applicable here. . This class returns an empty ArrayList&lt;&gt;() when we’ll need it for any reason. | CustomerSupport . Python version . class CustomerSupport: def __init__(self, processing_strategy: TicketOrderingStrategy): self.tickets = [] self.processing_strategy = processing_strategy def create_ticket(self, customer, issue): self.tickets.append(SupportTicket(customer, issue)) def process_tickets(self): # create the ordered list ticket_list = self.processing_strategy.create_ordering(self.tickets) # if it&#39;s empty, don&#39;t do anything if len(ticket_list) == 0: print(&quot;There are no tickets to process. Well done!&quot;) return # go through the tickets in the list for ticket in ticket_list: self.process_ticket(ticket) def process_ticket(self, ticket: SupportTicket): print(&quot;==================================&quot;) print(f&quot;Processing ticket id: {ticket.id}&quot;) print(f&quot;Customer: {ticket.customer}&quot;) print(f&quot;Issue: {ticket.issue}&quot;) print(&quot;==================================&quot;) . Java version . package edu.def.sp; import java.util.ArrayList; public class CustomerSupport { private ArrayList&lt;SupportTicket&gt; tickets; private TicketOrderingStrategy processingStrategy; CustomerSupport(TicketOrderingStrategy processingStrategy){ tickets = new ArrayList&lt;&gt;(); this.processingStrategy = processingStrategy; } public void createTicket(String customer, String issue){ tickets.add(new SupportTicket(customer, issue)); } public void processTickets(){ ArrayList&lt;SupportTicket&gt; ticketList = this.processingStrategy.createOrdering(this.tickets); if (ticketList.size() == 0){ System.out.println(&quot;There are no tickets to process. Well done!&quot;); return; } for (SupportTicket ticket: ticketList){ this.processTicket(ticket); } } /** * As it has only internal usage, we can define this function as a private one. * @param ticket */ private void processTicket(SupportTicket ticket){ System.out.println(&quot;==================================&quot;); System.out.println(&quot;Processing ticket id: &quot; + ticket.getId()); System.out.println(&quot;Customer: &quot; + ticket.getCustomer()); System.out.println(&quot;Issue: &quot; + ticket.getIssue()); System.out.println(&quot;==================================&quot;); } } . This class is the heart of the application; create customers ArrayList, add tickets to it, process tickets and show them to the user by any request. | We have two private parameters whose value will be assigned to them in the class’s constructor. | In the constructor, we pass an object of the TicketOrderingStrategy interface, which is a non-primitive data type. This object will define the ordering in this class. Also, we are creating a new ArrayList object in this constructor. | In the createTickets () public method, we create a SupportTicket object and add it to the tickets ArrayList. | In the proccessTicket() method, we are ordering the ticket ArrayList by passing this list to the processingStrategy object’s method (createOrdering()). This will return the desired ordered list, and the ticket - ArrayList will be replaced. Then, we will start to print each list entry by passing them to the processTicket() method. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/3-StrategyPattern.html",
            "relUrl": "/markdown/2022/06/19/3-StrategyPattern.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Dependency Inversion in Java",
            "content": "Dependency Inversion principles code translation in Java . Published by Saman Pordanesh . General Introduction . This topic discusses how we can implement some object-oriented definitions like Abstraction or Interfaces in a language like a python which doesn’t have these definitions locally. As Java is a strong OOP language, we already have these definitions for it. We will implement the translation of the video’s code here to understand how these principles work on Java. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Dependency Inversion lessons in python programming languages (dependency-inversion-after.py) | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.di (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . we create one .java file per each class under edu.def.di package. | We are going to discuss Switchable class more here. This class is an interface class and we use the “interface” keyword instead of “class”. But why this is an interface? The answer is that this class just contains the prototypes of methods without any implementation. It is an index which shows a specific structure but can have different functionality when we override it on the child class. Please read about the interface on OOP and interface on java. | When we created other classes (LightBulb.java, Fan.java, ElectricPowerSwitch.java), we need Main.java to contain our main function to run the program. | After that, we will start to translate all classes to their belonging files based on the Python source. We will compare all of them with the original version in the following section. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/di/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.di.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . Switchable . Python version . class Switchable(ABC): @abstractmethod def turn_on(self): pass @abstractmethod def turn_off(self): pass . Java version . package edu.def.di; public interface Switchable { void turnOn(); void turnOff(); } . This class is the main lesson for this session, as we are talking about interface and Switchable is an interface class. As we can see, we implemented it with “interface” keyword and it just contains prototype of each method, without any implementation or parameter. | As we don’t have interface in python, this class needs to inherit ABC class to act like an abstract class, although in Java we already have abstract and interface definitions locally. (in python version he used “@abstractmethod” keyword to show that they are abstract methods. Also, there are differences between abstract and interface which recommend learning about them.) | Its child classes will inherit all methods from it, and we will implement all methods at child classes under the “@Override” keyword. | As we talked about it before, we don’t need any implementation for both turnOn and turnOff methods at the interface. | LightBulb . Python version . class LightBulb(Switchable): def turn_on(self): print(&quot;LightBulb: turned on...&quot;) def turn_off(self): print(&quot;LightBulb: turned off...&quot;) . Java version . package edu.def.di; public class LightBulb implements Switchable{ @Override public void turnOn() { System.out.println(&quot;LightBulb: turned on...&quot;); } @Override public void turnOff() { System.out.println(&quot;LightBulb: turned off...&quot;); } } . This is one of the Switchable children which is inheriting all methods from its parent class. | “Implements Switchable” is the keyword for inheritance. | As its obvious, all methods from interface parent are being overriding in this class, although we can have more methods and parameters in this class which don’t have any connection whith the parent class. | Notice that in python version we simply use general inheritance implementation and redefine all methods without any keyword. | Fan . Python version . class Fan(Switchable): def turn_on(self): print(&quot;Fan: turned on...&quot;) def turn_off(self): print(&quot;Fan: turned off...&quot;) . Java version . package edu.def.di; public class Fan implements Switchable{ @Override public void turnOn() { System.out.println(&quot;Fan: turned on...&quot;); } @Override public void turnOff() { System.out.println(&quot;Fan: turned off...&quot;); } } . The same points as LightBulb class. . ElectricPowerSwitch . Python version . class ElectricPowerSwitch: def __init__(self, c: Switchable): self.client = c self.on = False def press(self): if self.on: self.client.turn_off() self.on = False else: self.client.turn_on() self.on = True . Java version . package edu.def.di; public class ElectricPowerSwitch { private Switchable client; private boolean on = false; ElectricPowerSwitch(Switchable client){ this.client = client; } public void press(){ if (on){ client.turnOff(); on = false; } else { client.turnOn(); on = true; } } } . This is a general class with specific functionality to act as an electric device. We will define the kind of device by passing related object to this class (this is an Aggregation relationship. More here). | We have two parameters. The first one (client) is a non-primary data type with type of Switchable and we will define its value on the class constructor. The second one (on) is a primary data type Boolean with a default value of false. In addition a public method press. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/2-DependencyInversion.html",
            "relUrl": "/markdown/2022/06/19/2-DependencyInversion.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Cohesion and Coupling in Java",
            "content": "Cohesion and Coupling principles code translation in Java . Published by Saman Pordanesh . Introduction . Cohesion is used to indicate the degree to which a class has a single, well-focused purpose. Coupling is all about how classes interact with each other; on the other hand, cohesion focuses on how the single class is designed. Higher the cohesiveness of the class, the better is the OO design. Benefits of Higher Cohesion: Highly cohesive classes are much easier to maintain and less frequently changed. | Such classes are more usable than others as they are designed with a well-focused purpose. | . | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Cohesion and Coupling lessons in python programming languages (coupling-cohesion-after.py) | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.cac (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/cac/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.cac.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . VehicleInfo . Python version . class VehicleInfo: def __init__(self, brand, electric, catalogue_price): self.brand = brand self.electric = electric self.catalogue_price = catalogue_price def compute_tax(self): tax_percentage = 0.05 if self.electric: tax_percentage = 0.02 return tax_percentage * self.catalogue_price def print(self): print(f&quot;Brand: {self.brand}&quot;) print(f&quot;Payable tax: {self.compute_tax()}&quot;) . Java version . package edu.def.cac; /** * A class with 3 private parameters and two public * methods. Also, a constructor with 3 arguments. */ public class VehicleInfo { private String brand; private boolean electric; private int cataloguePrice; VehicleInfo(String brand, boolean electric, int cataloguePrice){ this.brand = brand; this.electric = electric; this.cataloguePrice = cataloguePrice; } /** * * @return a double which is the computed tax. */ public double computeTax(){ double taxPercentage = 0.05; if (electric){ taxPercentage = 0.02; } return taxPercentage * cataloguePrice; } /** * */ public void print(){ System.out.println(&quot;Brand: &quot; + this.brand); System.out.println(&quot;Payable tax: &quot; + this.computeTax()); } } . we defined three private parameters in this class, and their values will be determined by the class instructor when we initialize the class. getters and setters for each private parameter, are not required, you can access fields directly by making parameters public in Java as well, but it’s (private parameters) frequently done in Java as an OOP principle. Still, as we won’t need direct access to any parameters in future, we do not implement them here (it’s acceptable). | Be careful that we specify all data types when we initialize them, although it’s unnecessary for python. | We can add strings together for printing by the “+” sign, although we used formatted string to do that on python. | Vehicle . Python version . class Vehicle: def __init__(self, id, license_plate, info): self.id = id self.license_plate = license_plate self.info = info def print(self): print(f&quot;Id: {self.id}&quot;) print(f&quot;License plate: {self.license_plate}&quot;) self.info.print() . Java version . package edu.def.cac; /** * Public class Vehicle with 3 private parameters * and one public method. Plus a constructor with * 3 arguments. */ public class Vehicle { private String id; private String licensePlate; private VehicleInfo info; Vehicle(String id, String licensePlate, VehicleInfo info){ this.id = id; this.licensePlate = licensePlate; this.info = info; } public void print(){ System.out.println(&quot;Id: &quot; + this.id); System.out.println(&quot;License plate: &quot; + this.licensePlate); this.info.print(); } } . A simple class which has three parameters. As we explained in the previous class, we defined all of them as “private” without any getter and setter. | The same point about joining strings together for printing in the print function. | VehicleRegistry . Python version . class VehicleRegistry: def __init__(self): self.vehicle_info = { } self.add_vehicle_info(&quot;Tesla Model 3&quot;, True, 60000) self.add_vehicle_info(&quot;Volkswagen ID3&quot;, True, 35000) self.add_vehicle_info(&quot;BMW 5&quot;, False, 45000) self.add_vehicle_info(&quot;Tesla Model Y&quot;, True, 75000) def add_vehicle_info(self, brand, electric, catalogue_price): self.vehicle_info[brand] = VehicleInfo(brand, electric, catalogue_price) def generate_vehicle_id(self, length): return &#39;&#39;.join(random.choices(string.ascii_uppercase, k=length)) def generate_vehicle_license(self, id): return f&quot;{id[:2]}-{&#39;&#39;.join(random.choices(string.digits, k=2))}-{&#39;&#39;.join(random.choices(string.ascii_uppercase, k=2))}&quot; def create_vehicle(self, brand): id = self.generate_vehicle_id(12) license_plate = self.generate_vehicle_license(id) return Vehicle(id, license_plate, self.vehicle_info[brand]) . Java version . package edu.def.cac; import java.util.HashMap; import java.util.Random; public class VehicleRegistry { /** * We use HashMap in java when we want to have a data structure as shows Key -&gt; Value * here, the key is the car&#39;s brand and its is a VehicleInfo object */ HashMap&lt;String, VehicleInfo&gt; vehicleInfo = new HashMap&lt;&gt;(); VehicleRegistry(){ //Saturating the HashMap on constructor this.addVehicleInfo(&quot;Tesla Model 3&quot;, true, 60000); this.addVehicleInfo(&quot;Volkswagen ID3&quot;, true, 35000); this.addVehicleInfo(&quot;BMW 5&quot;, false, 45000); this.addVehicleInfo(&quot;Tesla Model Y&quot;, true, 75000); } public void addVehicleInfo(String brand, boolean electric, int cataloguePrice){ /*create an entry for the HashMap which the Key is String type and the Vale is a non-primary data type VehicleInfo */ this.vehicleInfo.put(brand, new VehicleInfo(brand, electric, cataloguePrice)); } public String generateVehicleId(int length){ return getSaltString(&quot;uppercase&quot;, length); } public String generateVehicleLicense(String id){ return id.substring(0, 2) + &quot;-&quot; + getSaltString(&quot;digits&quot;, 2) + &quot;-&quot; + getSaltString(&quot;uppercase&quot;, 2); } public Vehicle createVehicle(String brand){ String id = generateVehicleId(12); String licensePlate = generateVehicleLicense(id); return new Vehicle(id, licensePlate, vehicleInfo.get(brand)); } /** * As we dont have a simple function to arrange a random string on Java, we are implementing * this helper method to help us create one. * It acts like &quot;random.choices&quot; in Python * @param ascii * @return */ protected String getSaltString(String ascii, int length) { //char sets based on the incoming argument String SALTCHARS; switch (ascii){ case &quot;uppercase&quot;: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; break; case &quot;lowercase&quot;: SALTCHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;; break; case &quot;digits&quot;: SALTCHARS = &quot;1234567890&quot;; break; default: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; } StringBuilder salt = new StringBuilder(); Random rnd = new Random(); while (salt.length() &lt; length) { // length of the random string. int index = (int) (rnd.nextFloat() * SALTCHARS.length()); salt.append(SALTCHARS.charAt(index)); } return salt.toString(); } } . In this class, we are using vehicleInfo HashMap as an alternative data structure for Python’s dictionary. HashMap is a data structure which allows us to define a key for a specific value and get access to that value with the key in future (key -&gt; value). In this class, we use a car’s brand as a key and attach it to belonging vehicle information (value). As a result, we will be able to access each car’s brand information through key -&gt; value. In addition, this parameter is a private one. | ` `We initialized vehicleInfo with some data at the class construction VehicleRegistry. This isn’t a good and professional way to saturate a hash map, but it works in this example just for educational purposes. | The function addVehicleInfo is for adding new data to the vehicleInfo HashMap by getting three arguments. The first argument will be the key on the HashMap, and the others will be used to initialize an object from VehicleInfo class. As you can see, vehicleInfo.put(key, value) is a function to add an entry to the HashMap. | At the function generateVicleId, we see a significant difference between the Java version and the Python one. We need to define the getSaltString helper method to generate random strings based on the three categories of ASCII characters (uppercase, lowercase, digits). However, we already have a predefined function to do this in Python. In this function, we need to return a random string of uppercase characters with the size of length, which is the function’s argument. . | At generateVehicleLicense, we create a specific string format. By the substring() method, we can split a particular part of a string. It’s identical to Python’s string[start, end] method. | As we said before, getSaltString is a helper method to generate random strings based on specific size and type. You can find more here. | Application . Python version . class Application: def register_vehicle(self, brand: string): # create a registry instance registry = VehicleRegistry() vehicle = registry.create_vehicle(brand) # print out the vehicle information vehicle.print() . Java version . package edu.def.cac; public class Application { /** * to put all different components togather and create an application for a specific brand of car. * @param brand: main input to create an application. */ public void registerVehicle(String brand){ VehicleRegistry registry = new VehicleRegistry(); Vehicle vehicle = registry.createVehicle(brand); vehicle.print(); } } . This class, with a simple public function, is created to put all other classes and their method together to lunch an application. The only argument that the registerVehicle method needs is a car’s brand string. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/1-CohesionAndCoupling.html",
            "relUrl": "/markdown/2022/06/19/1-CohesionAndCoupling.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://de-fellows.github.io/RexCoding/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://de-fellows.github.io/RexCoding/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://de-fellows.github.io/RexCoding/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}