{
  
    
        "post0": {
            "title": "SOLID principles in Java",
            "content": "SOLID principles code translation in Java . Published by Saman Pordanesh . Introduction . SOLID is an acronym for the first five object-oriented design (OOD) principles. These principles establish practices that lend to developing software with considerations for maintaining and extending as the project grows. Adopting these practices can also contribute to avoiding code smells, refactoring code, and Agile or Adaptive software development. SOLID stands for: S - Single-responsiblity Principle O - Open-closed Principle L - Liskov Substitution Principle I - Interface Segregation Principle D - Dependency Inversion Principle | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better. | This translation is based on the final code source of Solid Principles lessons in python programming languages (dependency-inversion-after.py) | We need a separate class with the main function to run the program, despite Python, which you can each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.solid (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/solid/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.solid.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . Order . Python version . class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = &quot;open&quot; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total . Java version . package edu.def.solid; public class Order { private String[] items; private int[] quantities; private int[] prices; private String status = &quot;open&quot;; int numberOfItems = 0; Order(int numberOfItems){ items = new String[numberOfItems]; quantities = new int[numberOfItems]; prices = new int[numberOfItems]; } public void addItem(String name, int quantity, int price){ this.items[numberOfItems] = name; this.quantities[numberOfItems] = quantity; this.prices[numberOfItems] = price; numberOfItems++; } public int totalPrice(){ int total = 0; for (int i = 0; i &lt; numberOfItems; i++){ total += this.quantities[i] * this.prices[i]; } return total; } public void setStatus(String status) { this.status = status; } public String getStatus() { return status; } } . In this class, we need to clarify each array’s size as a Java programming rule. We can do it at the initializer by passing the number of items on the class constructor. | We implemented all variables (items, quantities, …) as class attributes on Java with private visibility to protect them from direct access out of the class. Also, status has a default value of “open”. | A variable like numberOfItems is needed to keep track of the arrays and access them later, as Java doesn’t automatically detect where should add a new item in the array (nothing like append in python). In addition, we should keep updating this variable by adding every single item (in the addItem function). | getters and setters for each private parameter, are not required; You can access fields directly by making parameters public in Java as well, but it’s (private parameters) frequently done in Java as an OOP principle. We followed that principle here and as we will need to access status in other classes, we defined getter and setter for this class’s parameter. | Authorizer . Python version . class Authorizer(ABC): @abstractmethod def is_authorized(self) -&gt; bool: pass . Java version . package edu.def.solid; public interface Authorizer { public boolean isAuthorized(); } . This class was an abstract class on the python version. Abstracts are usually used when we want to implement a specific function with all its functionalities that all children will use in the future. But when we need only the prototype (function naming, return type and arguments only), which will be implemented by each child later, we use interfaces in Java programming. As a result, we implement the Authorizer class as an interface class containing the isAuthotized function prototype. . | A class in Java can inherit an interface by the “implements” keyword after the class name. . | public class AuthorizerSMS implements Authorizer{ ... . Also, all interface methods should be overridden in this child class (implement them completely) . @Override public boolean isAuthorized() { return this.authorized; } . AuthorizerSMS . Python version . class Authorizer_SMS(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f&quot;Verifying SMS code {code}&quot;) self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerSMS implements Authorizer{ private boolean authorized = false; public void verifyCode(int code){ System.out.print(&quot;Verifying SMS code &quot; + code); this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . We defined the variable authorized as a private class attribute. | The isAuthorized method was overridden based on its interface, inheriting that (Authorizer). . | At the verifyCode method, we appended the variable to the printed text by the “+**” sign, although in python, a formatting printing method was used (the **f char at the start of the string) | AuthorizerGoogle . Python version . class Authorizer_Google(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f&quot;Verifying Google auth code {code}&quot;) self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerGoogle implements Authorizer { private boolean authorized = false; public void verifyCode(int code){ System.out.print(&quot;Verifying Google code &quot; + code); this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . The same points as AuthorizerSMS . AuthorizerRobot . Python version . class Authorizer_Robot(Authorizer): def __init__(self): self.authorized = False def not_a_robot(self): self.authorized = True def is_authorized(self) -&gt; bool: return self.authorized . Java version . package edu.def.solid; public class AuthorizerRobot implements Authorizer { private boolean authorized = false; public void notARobot(){ this.authorized = true; } @Override public boolean isAuthorized() { return this.authorized; } } . The same points as AuthorizerSMS . PaymentProcessor . Python version . class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass . Java version . package edu.def.solid; public interface PaymentProcessor { public void pay(Order order) throws Exception; } . this class is an interface and acts the same as the Authorizer class. This is an interface which imposes the implementation of a specific method on each child, which will be inherent in this interface. | In addition, be careful that the order argument in the payment method is in the type of Order class. (We call it non-primitive data type) | We have an Exception method under a specific condition in the python. In Java, we must specify the “throws Exception” keyword on the function’s prototype and interface. | DebitPaymentProcessor . Python version . class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: Authorizer): self.security_code = security_code self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(&quot;Not authorized&quot;) print(&quot;Processing debit payment type&quot;) print(f&quot;Verifying security code: {self.security_code}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class DebitPaymentProcessor implements PaymentProcessor{ private int securityCode; private Authorizer authorizer; DebitPaymentProcessor(int securityCode, Authorizer authorizer){ this.securityCode = securityCode; this.authorizer = authorizer; } @Override public void pay(Order order) throws Exception { if (!authorizer.isAuthorized()){ throw new Exception(&quot;Not authorized&quot;); } System.out.println(&quot;Processing debit payment type&quot;); System.out.println(&quot;Verifying security code: &quot; + this.securityCode); order.setStatus(&quot;paid&quot;); } } . We have a constructor to specify two-class parameter values, securitycode and authorizer. Notice that authorizer is a non-primitive data type in the type of Authorizer. | We specified all parameters as private because of the Java OOP rules and without getter and setter, as they are being used only for internal purposes. | The pay method is an overridden method from the PaymentProcessor interface. It shows us that this class inherits the PaymentProcessor interface. | The pay method in this class throws an exception, so we need “throws Exception” keyword at the method’s prototype. | CreditPaymentProcessor . Python version . class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(&quot;Processing credit payment type&quot;) print(f&quot;Verifying security code: {self.security_code}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class CreditPaymentProcessor implements PaymentProcessor { private int securityCode; CreditPaymentProcessor(int securityCode){ this.securityCode = securityCode; } @Override public void pay(Order order){ System.out.println(&quot;Processing credit payment type&quot;); System.out.println(&quot;Verifying security code: &quot; + this.securityCode); order.setStatus(&quot;paid&quot;); } } . The same points of debitPaymentProcessor will apply for this class, except we don’t have the authorizer parameter and any exceptions for the pay method. . PaypalPaymentProcessor . Python version . class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address, authorizer: Authorizer): self.email_address = email_address self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(&quot;Not authorized&quot;) print(&quot;Processing paypal payment type&quot;) print(f&quot;Using email address: {self.email_address}&quot;) order.status = &quot;paid&quot; . Java version . package edu.def.solid; public class PaypalPaymentProcessor implements PaymentProcessor{ private String emailAddress; private Authorizer authorizer; PaypalPaymentProcessor(String emailAddress, Authorizer authorizer){ this.emailAddress = emailAddress; this.authorizer = authorizer; } @Override public void pay(Order order) throws Exception { if (!authorizer.isAuthorized()){ throw new Exception(&quot;Not authorized&quot;); } System.out.println(&quot;Processing paypal payment type&quot;); System.out.println(&quot;Using email address: &quot; + this.emailAddress); order.setStatus(&quot;paid&quot;); } } . The same points of debitPaymentProcessor will apply to this class. Only some changes about authentication and change from security code to email verification. .",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/9-SolidPrinciples.html",
            "relUrl": "/markdown/2022/06/19/9-SolidPrinciples.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "MVC in Java",
            "content": "MVC (Model-View-Controller) code translation in Java . Published by Saman Pordanesh . General Introduction . MVC (Model-View-Controller) is a pattern in software design commonly used to implement user interfaces, data, and controlling logic. It emphasizes the separation between the software’s business logic and display. For more, click here. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of the MVC lessons in python programming languages (mvc-after-strategy.py). | Point: This translation is much more different from the original Python version’s structure, libraries, and functionalities in this Java version. It’s caused as we have two different libraries for UI (user interface) in Python and Java, which follow different structures. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on Java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with the same directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.mvc (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. In addition, we have a sub package edu.def.mvc.uuid for the UUID interface and its children, as far as the strategy is concerned. (Have different strategies for generating different UUIDs) | However, packages are unnecessary; you could use a default package or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.mvc package. They can be interfaces and child classes or simple classes. In addition, in this lesson, we have a sub-package “edu.def.mvc.uuid” in a separate folder on the main package directory to hold a class category that behaves similarly. Learn more about sub-packages here. | In this project, we use Java GUI libraries AWT and Swing, which have a different structure and functionality than Python’s Tkinter library for the same purpose. E.g., we don’t need a loop in the Java version to run the UI, although we need it in the Python version. Complete tutorial about Java GUI with Swing here. | We have three MVC classes: Model.java, Controller.java and View.java**. In addition, we have a class called **SwingView.java, which implements View.java and handle all user interface codes. From that class, we combine all MVC principles to run an application. Finally, the interface GenerateUuid.java and its children Uuid.java, Uuid4.java and UuidString.java are classes to generate different UUIDs, depending on which one we choose on the main () method. | Main.java contains our main () method to run the program. | Note that all steps here are entirely for the best OOP practice in Java programming; They can be done more straightforwardly, but not the best OOP ways. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/mvc/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.mvc.Main . | If your main function is in a different class, but the name of that class instead of Main at the end of the command | You can find more about compiling instructions here. | . Classes changes . Model . Python version . class Model: def __init__(self): self.uuid = [] . Java version . package edu.def.mvc; import java.util.ArrayList; import java.util.UUID; /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ /** * This is the Model class which should act as a database in this program. * This model is pretty simple, and we can hold the whole data on a simple ArrayList. * In complicated versions, Model class should connect with an external database. */ public class Model { private ArrayList&lt;UUID&gt; uuids; Model(){ uuids = new ArrayList&lt;&gt;(); } public void setUuids(ArrayList&lt;UUID&gt; uuids) { this.uuids = uuids; } public ArrayList&lt;UUID&gt; getUuids() { return uuids; } public void addUuid(UUID uuid){ this.uuids.add(uuid); } public void clearModel(){ this.uuids.clear(); } } . This class required an ArrayList to act as a data holder. We will keep all generated UUIDs in this ArrayList and use them through the program. | As the ArrayList is a private parameter and we need access to it in other classes, we have getter and setter methods for this purpose. In addition, addUuid () is used to add a generated UUID to the model and clearModel () is used to clear the whole model when needed. However, by making the ArrayList a public parameter, we won’t need getter, setter, add and clean functions, but all of them are for best OOP practices. | Controller . Python version . class Controller: def __init__(self, model, view, generate_uuid): self.model = model self.view = view self.generate_uuid = generate_uuid def start(self): self.view.setup(self) self.view.start_main_loop() def handle_click_generate_uuid(self): # generate a uuid and add it to the list self.model.uuid.append(self.generate_uuid()) self.view.append_to_list(self.model.uuid[-1]) def handle_click_clear_list(self): # clear the uuid list in the model and the view self.model.uuid = [] self.view.clear_list() . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import edu.def.mvc.uuid.GenerateUuid; import java.util.UUID; /** * Controller class */ public class Controller { private Model model; private View view; private GenerateUuid generateUuid; Controller(Model model, View view, GenerateUuid uuid){ this.model = model; this.view = view; this.generateUuid = uuid; } //start the initial UI public void start(){ this.view.setup(this); } //handle &quot;Generate UUID&quot; button and public void handleClickGenerateUuid(){ this.model.addUuid(this.generateUuid.generateUuid()); } //handle &quot;Clear list&quot; button and public void handleClickClearList(){ this.model.clearModel(); this.view.clearList(); } //getting the Model object to use its data public Model getModel() { return model; } } . This class controls all actions in the program and acts as a connector between View and Model as well (as you can see, we have both View and Model objects as parameters of this class). | We have a parameter of the GeneratedUuid interface. We pass the GeneratedUuid children to the Controller class by its constructor to define which kind of UUID we want to generate in the application. | In the start () method, we call the setup () method of the View object to start GUI’s engine. | The following method is handleClickGenerateUuid () when the user clicks on the “Generate UUID” button. This method should generate a UUID by generateUuid object and adding it to the model. | The method handleClickClearList () handles the functionality of the “Clear List” button and clears the model entirely. | View . Python version . class View(ABC): @abstractmethod def setup(self, controller): pass @abstractmethod def append_to_list(self, item): pass @abstractmethod def clear_list(self): pass @abstractmethod def start_main_loop(self): pass . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import javax.swing.*; import java.util.UUID; public abstract class View { public abstract void setup(Controller controller); public abstract void appendToList(UUID item); public abstract void clearList(); public abstract void startMainLoop(); } . This class is an abstract with four methods to handle the view of the application. | The setup () method will use to contain and start a GUI engine. | The method appendToList () is a method to run and handle the “Generate UUID” button view on the application. | Also, the method clearList () is a method to run and handle the “Clear List” button view on the application. | Finally, startMainLoop() contains a method to make the frame visible. Unlike Python, in the Java version of GUI, we don’t need a loop to run the application. | SwingView (as TkView in the Python version) . Python version . class TkView(View): def setup(self, controller): # setup tkinter self.root = tk.Tk() self.root.geometry(&quot;400x400&quot;) self.root.title(&quot;UUIDGen&quot;) # create the gui self.frame = tk.Frame(self.root) self.frame.pack(fill=tk.BOTH, expand=1) self.label = tk.Label(self.frame, text=&quot;Result:&quot;) self.label.pack() self.list = tk.Listbox(self.frame) self.list.pack(fill=tk.BOTH, expand=1) self.generate_uuid_button = tk.Button(self.frame, text=&quot;Generate UUID&quot;, command=controller.handle_click_generate_uuid) self.generate_uuid_button.pack() self.clear_button = tk.Button(self.frame, text=&quot;Clear list&quot;, command=controller.handle_click_clear_list) self.clear_button.pack() def append_to_list(self, item): self.list.insert(tk.END, item) def clear_list(self): self.list.delete(0, tk.END) def start_main_loop(self): # start the loop self.root.mainloop() . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.UUID; /** * this class handles all three MVC classes to generate a UI application. * It uses Swing &amp; AWT libraries for generating GUI. */ class SwingView extends View implements ActionListener { JFrame frame; TextArea display; JButton createButton; JButton clearButton; Controller controller; @Override public void setup(Controller controller) { // A controller object to control all principles in the program // from a unique class. this.controller = controller; this.frame = new JFrame(); // Create a list for holding all generated uuids // responsive to add and clear by two &quot;generateButton&quot; and // &quot;clearButton&quot; buttons. this.display = new TextArea(&quot;&quot;, 20, 80); this.display.setEditable(false); this.startMainLoop(); // Create two button for generating uuid and append to the list (generateButton) // and clear the least (clearButton) this.createButton = new JButton(&quot;Generate UUID&quot;); this.createButton.addActionListener(this); this.clearButton = new JButton(&quot;Clear List&quot;); this.clearButton.addActionListener(this); JPanel buttonPanel = new JPanel(); buttonPanel.setLayout(new GridLayout(0,2)); buttonPanel.add(this.createButton); buttonPanel.add(this.clearButton); Container content = this.frame.getContentPane(); content.setLayout(new BorderLayout()); content.add(&quot;Center&quot;, this.display); content.add(&quot;South&quot;, buttonPanel); this.frame.setPreferredSize(new Dimension(300, 200)); this.frame.setTitle(&quot;UUID generator&quot;); this.frame.pack(); } @Override public void appendToList(UUID item) { this.display.append(item.toString() + &quot; n&quot;); } @Override public void clearList() { this.display.setText(&quot;&quot;); } @Override public void startMainLoop() { this.frame.setVisible(true); } @Override public void actionPerformed(ActionEvent e) { if(e.getSource() == this.createButton) { this.controller.handleClickGenerateUuid(); Model model = controller.getModel(); this.appendToList(model.getUuids().get(model.getUuids().size()-1)); }else if (e.getSource() == this.clearButton) { this.controller.handleClickClearList(); this.clearList(); } } } . Java’s GUI and Swing library principles are out of this course’s scope. We recommend reading more about Swing library. Also, this and this video may help you to understand better. | As we said, this class inherits the View abstract. As a result, we need to override all methods of that abstract in this child class. | GenerateUuid (plus all three children who are inheriting this interface) . Python version . # functional strategy def generate_uuid1(): return uuid.uuid1() def generate_uuid4(): return uuid.uuid4() def generate_simple_id(): return &#39;&#39;.join(random.choices(string.ascii_lowercase, k=30)) class Model: def __init__(self): self.uuid = [] . Java version . /** @author Saman Pordanesh &lt;a href=&quot;mailto:sina.pordanesh@yahoo.com&quot;&gt; sina.pordanesh@yahoo.com&lt;/a&gt; @version 1.0 @since 1.0 */ package edu.def.mvc.uuid; import java.util.UUID; /** * Interface for all UUIDs generators classes. * Only contains one method for generating a kind of UUIDs. */ public interface GenerateUuid { public UUID generateUuid(); } . //For UUID1 public class Uuid1 implements GenerateUuid{ @Override public UUID generateUuid() { byte[] byteName = { 50, 40, 30, 20, 10 }; return UUID.nameUUIDFromBytes(byteName); } } . //For UUID4 public class Uuid4 implements GenerateUuid{ @Override public UUID generateUuid() { return UUID.randomUUID(); } } . //For UUIDString public class UuidString implements GenerateUuid{ @Override public UUID generateUuid() { return UUID.fromString(&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d&quot;); } } . This interface and its children under a sub package were substituted for three functions in Python language, which are responsible for generating different UUIDs. While this structure could be much simpler without any interface, inheritance, or sub-package, we are following OOP principles for the best practice. | This interface has one method that will be overridden through different child classes. | The generateUuid () method generates different kinds of UUID, which the Java programming language allows us to generate. | We created three other classes based on this interface which are Uuid1.java, Uuid4.java and UuidString.java**, and each of them will generate a different **UUID string. | To generate those UUIDs, we used a native Java library called “java.util.UUID”. We highly recommend reading about it here. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/8-MVC.html",
            "relUrl": "/markdown/2022/06/19/8-MVC.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Template Method & Bridge in Java",
            "content": "Template Method &amp; Bridge code translation in Java . Published by Saman Pordanesh . General Introduction . The Template Method design pattern is to define an algorithm as a skeleton of operations and leave the details to be implemented by the child classes. The parent class preserves the overall structure and sequence of the algorithm. Also, In computer science, bridging describes systems that map the runtime behaviour of different programming languages so they can share common resources. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of the Template method and Bridge lessons in python programming languages (with-bridge.py). That is the complete file, which contains all principles such as Abstraction, Inheritance, etc. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on Java is different. You can find more information here. | There is a UML.png file in this repository’s folder, which shows relationships between different classes. Please check it as a good reference for understanding this code. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with the same directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.tmab (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are unnecessary; you could use a default package or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.tmab package. They can be interfaces, abstractions, child classes or simple classes. | After that, we will translate all classes to their belonging files based on the Python source. We will compare them with the original version in the following section. | This article will introduce the Abstract class and method. The abstract is a kind of parent class with both methods and parameters. Methods can be in two different categories; Abstract methods are those that we implement in the abstract class, and all children will inherit them the same as the parent. The other kind of method is just a prototype that shows the return type, name and arguments needed. Still, we will implement the content of the method on each child individually using the override keyword. We implement an abstract class by using the “abstract” keyword at the start of the class definition. | Main.java contains our main() method to run the program. | Note that all steps here are entirely for the best OOP practice in Java programming; They can be done more straightforwardly, but not the best OOP ways. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/tmab/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.tmab.Main . | If your main function is in a different class, but the name of that class instead of Main at the end of the command | You can find more about compiling instructions here. | . Classes changes . Exchange . Python version . class Exchange(ABC): @abstractmethod def connect(self): pass @abstractmethod def get_market_data(self, coin: str) -&gt; List[float]: pass . Java version . package edu.def.tmab; import java.util.ArrayList; public interface Exchange { public void connect(); public ArrayList&lt;Float&gt; getMarketData(String coin); } . This class is defined as an interface class, although it was described as an abstract one on the Python version. The reason is that we don’t have an interface class specifically on Python programming languages. Please read about the differences between interface and abstract class. | In this class, we define the prototype of each method that a child will inherit. Then, we will override it at the child class later. | Binance . Python version . class Binance(Exchange): def connect(self): print(f&quot;Connecting to Binance exchange...&quot;) def get_market_data(self, coin: str) -&gt; List[float]: return [10, 12, 18, 14] . Java version . package edu.def.tmab; import java.util.ArrayList; public class Binance implements Exchange{ @Override public void connect() { System.out.println(&quot;Connecting to Binance exchange...&quot;); } @Override public ArrayList&lt;Float&gt; getMarketData(String coin) { return new ArrayList&lt;&gt;(); } } . This is a child class which inherits the interface Exchange. As you can see, we override both interface methods in this class. Also, we don’t have any limitations to adding more parameters and methods in this class beyond the inherited interface. | In the getMarketData() method, we initialized the ArrayList by some numbers differently from Python. This is the proper way to do that In Java. You can find more here. (“f” in front of each number means “float” data type) | Coinbase . Python version . class Coinbase(Exchange): def connect(self): print(f&quot;Connecting to Coinbase exchange...&quot;) def get_market_data(self, coin: str) -&gt; List[float]: return [10, 12, 18, 20] . Java version . package edu.def.tmab; import java.util.ArrayList; public class Coinbase implements Exchange{ @Override public void connect() { System.out.println(&quot;Connecting to Binance exchange...&quot;); } @Override public ArrayList&lt;Float&gt; getMarketData(String coin) { return new ArrayList&lt;&gt;(); } } . The same point as the Binance class. . TradingBot . Python version . class TradingBot(ABC): def __init__(self, exchange: Exchange): self.exchange = exchange def check_prices(self, coin: str): self.exchange.connect() prices = self.exchange.get_market_data(coin) should_buy = self.should_buy(prices) should_sell = self.should_sell(prices) if should_buy: print(f&quot;You should buy {coin}!&quot;) elif should_sell: print(f&quot;You should sell {coin}!&quot;) else: print(f&quot;No action needed for {coin}.&quot;) @abstractmethod def should_buy(self, prices: List[float]) -&gt; bool: pass @abstractmethod def should_sell(self, prices: List[float]) -&gt; bool: pass . Java version . package edu.def.tmab; import java.util.ArrayList; public abstract class TradingBot { private Exchange exchange; TradingBot(Exchange exchange){ this.exchange = exchange; } public void checkPrices(String coin){ this.exchange.connect(); ArrayList&lt;Float&gt; prices = this.exchange.getMarketData(coin); boolean shouldBuy = this.shouldBuy(prices); boolean shouldSell = this.shouldSell(prices); if (shouldBuy){ System.out.println(&quot;You should buy &quot; + coin + &quot;!&quot;); } else if (shouldSell) { System.out.println(&quot;You should sell &quot; + coin + &quot;!&quot;); } else { System.out.println(&quot;No action needed for &quot; + coin + &quot;.&quot;); } } public abstract boolean shouldBuy(ArrayList&lt;Float&gt; prices); public abstract boolean shouldSell(ArrayList&lt;Float&gt; prices); } . This class is an Abstract class, as we discussed at Implementation Instruction. You can see the “abstract” keyword in the class implementation, which is necessary for implementation. | As you can see, we have both implemented method and abstract method (only prototype) methods in this class. We will override all abstract methods for the children who will inherit from. In terms of the implemented method, all children will inherit them precisely with the same functionality we defined for the method in the abstraction class. We won’t override them later. | checkPrices() is a local method, but shouldBuy() and shouldSell() are abstract methods. | As we said before, an abstract class acts like a regular class and can have local methods, parameters, a constructor, and abstract methods. | AverageTrader . Python version . class AverageTrader(TradingBot): def list_average(self, l: List[float]) -&gt; float: return sum(l) / len(l) def should_buy(self, prices: List[float]) -&gt; bool: return prices[-1] &lt; self.list_average(prices) def should_sell(self, prices: List[float]) -&gt; bool: return prices[-1] &gt; self.list_average(prices) . Java version . package edu.def.tmab; import java.util.ArrayList; public class AverageTrader extends TradingBot{ /** * in java, when a class inherits an abstraction parent, we should have the constructor for the parent on the child class as well. The keyword for it is &quot;super&quot;. * @param exchange */ AverageTrader(Exchange exchange) { super(exchange); } public float listAverage(ArrayList&lt;Float&gt; list){ //we don&#39;t have any function to calculate sum of the // item on a list automatically. float sum = 0; for (float item: list){ sum += item; } return sum/list.size(); } @Override public boolean shouldBuy(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. return prices.get(prices.size() - 1) &lt; this.listAverage(prices); } @Override public boolean shouldSell(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. return prices.get(prices.size() - 1) &gt; this.listAverage(prices); } } . This child inherits the TradingBot abstraction class through the “extends” keyword. | The critical point is that we should first feed the parent’s constructor from this class’s constructor. It can be done by a super() method which takes arguments if the parent’s constructor needs any. You can find out more here. Also, we can initialize more parameters in this constructor if the class has any local ones. | As it is clear, we have two overridden methods, shouldBuy() and shouldSell() , which are abstract methods that belong to the abstract parent. In addition, we have a local method listAverage() . | MinMaxTrader . Python version . class MinMaxTrader(TradingBot): def should_buy(self, prices: List[float]) -&gt; bool: return prices[-1] == min(prices) def should_sell(self, prices: List[float]) -&gt; bool: return prices[-1] == max(prices) . Java version . package edu.def.tmab; import java.util.ArrayList; import java.util.Collections; import java.util.Objects; public class MinMaxTrader extends TradingBot{ /** * in java, when a class inherits an abstraction parent, we should have the constructor for the parent on the child class as well. The keyword for it is &quot;super&quot;. * @param exchange */ MinMaxTrader(Exchange exchange) { super(exchange); } @Override public boolean shouldBuy(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. //Also, Collections.min() will find the maximum item in a list return Objects.equals(prices.get(prices.size() - 1), Collections.min(prices)); } @Override public boolean shouldSell(ArrayList&lt;Float&gt; prices) { // &quot;(prices.size() - 1)&quot; on get() method means getting the last item of the list. //Also, Collections.max() will find the maximum item in a list. return prices.get(prices.size() - 1) == Collections.max(prices); } } . The same points as AverageTrader class. .",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/6-TemplateMethodAndBridge.html",
            "relUrl": "/markdown/2022/06/19/6-TemplateMethodAndBridge.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "The Strategy Pattern in Java",
            "content": "The Strategy Pattern code translation in Java . Published by Saman Pordanesh . General Introduction . Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Strategy Pattern lessons in python programming languages (strategy-after.py) Point: This part was done in two different (oop &amp; functional) methods. This translation is based on the oop method, and we didn’t translate the functional one, as that method doesn’t work in Java very well, although in Python may work well. | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project by an exact directory with all dependencies can be a good practce OOP designing. | We defined a package name for this project as edu.def.sp (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . We will create one .java file per class under edu.def.sp package. | As we have different ordering methods, we’ll define one class per each ordering way. They all inherit an interface (TicketOrderingStrategy.java) that contains only one ordering method (createOrdering.java). | As mentioned, one class for each ordering method is needed, which will be: FIFOOrderingStrategy.java – FILOOrderingStrategy.java - RandomOrderingStrategy.java – BlackHoleStrategy.java . | When creating other classes (SuportTicket.java &amp; CustomSupport.java), we need Main.java to contain our main function to run the program. | After that, we will translate all classes to their belonging files based on the Python source. We will compare them with the original version in the following section. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/sp/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.sp.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . SupportTicket . Python version . class SupportTicket: def __init__(self, customer, issue): self.id = generate_id() self.customer = customer self.issue = issue def generate_id(length=8): # helper function for generating an id return &#39;&#39;.join(random.choices(string.ascii_uppercase, k=length)) . Java version . package edu.def.sp; import java.util.Random; public class SupportTicket { private String id; private String customer; private String issue; SupportTicket(String customer, String issue){ this.id = getSaltString(&quot;uppercase&quot;, 8); this.customer = customer; this.issue = issue; } public String getId() { return id; } public String getCustomer() { return customer; } public String getIssue() { return issue; } /** * As we dont have a simple function to arrange a random string on Java, we are implementing * this helper method to help us create one. * It acts like &quot;random.choices&quot; in Python * @param ascii * @return */ private String getSaltString(String ascii, int length) { //char sets based on the incoming argument String SALTCHARS; switch (ascii){ case &quot;uppercase&quot;: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; break; case &quot;lowercase&quot;: SALTCHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;; break; case &quot;digits&quot;: SALTCHARS = &quot;1234567890&quot;; break; default: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; } StringBuilder salt = new StringBuilder(); Random rnd = new Random(); while (salt.length() &lt; length) { // length of the random string. int index = (int) (rnd.nextFloat() * SALTCHARS.length()); salt.append(SALTCHARS.charAt(index)); } return salt.toString(); } } . This is a class for creating tickets with three parameters id, customer, issue, and three getters for each parameter. As we are defining the parameter values on the constructor and won’t need to change them separately later, we don’t have a setter method for any parameter. Aslo, we can access parameters directly by making them public, but we use private parameters as an OOP designing principle. | The constructor received two arguments for customer and issue, but Id will be valued by generating a random string generator. | The only private method used to generate a random string with a specified size (we need to define this function as we don’t have any predefined method to do that in Java, although Python has). | TicketOrderingStrategy . Python version . class TicketOrderingStrategy(ABC): @abstractmethod def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: pass . Java version . package edu.def.sp; import java.util.ArrayList; public interface TicketOrderingStrategy { /** * A function which receives a list and return another list based on the ordering type. * @param list: an argument of ArrayList data type which contains SupportTicket objects * @return: the same data type of incoming argument, but with different ordering */ public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list); } . This is the interface we discussed at instruction, which all other ordering classes will inherit. We will override this interface’s createOrdering() method in all those classes. | As we can see, the creatingOrdering() method’s prototype defines which arguments are needed for this method and what will be its return value data type. | FIFOOrderingStrategy . Python version . class FIFOOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: return list.copy() . Java version . package edu.def.sp; import java.util.ArrayList; public class FIFOOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { return (ArrayList&lt;SupportTicket&gt;) list.clone(); } } . This class is one of the ordering ways classes implemented(inherited) from the TicketSupportingStrategy interface. | We have overridden the interface’s method as our desire for this class of ordering. | The list is already in order in this ordering method (first in, first out) der. You need to return it by creating a copy through the clone method. | Clone: clone() is a method to deeply copy an object in Java programming languages. When we use the “=” sign to copy an object, we are putting the address of the source (obj1) object to the destination (obj2); this means that if we change the boj1’s value, obj2’s value will be adjusted consequently. But with the clone() method, we can create an independent copy of obj1 and assign it to the obj2, although still, we can do more about making a completely separate copy, which is out of the scope of this article. Please click here for more. | FILOOrderingStrategy . Python version . class FILOOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: list_copy = list.copy() list_copy.reverse() return list_copy . Java version . package edu.def.sp; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; public class FILOOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { //clone() reates a partial deep copy of the object ArrayList&lt;SupportTicket&gt; listCopy = (ArrayList&lt;SupportTicket&gt;) list.clone(); //a function to reverse an ArrayList Collections.reverse(listCopy); return listCopy; } } . Most of the FIFOOrderingStrategy’s points are applicable here. . In this ordering class, after making a copy of the list by clone, we should reverse the list because of our ordering way (first in, last out). We did it using the Collection class and its method reverse(), which reversed the list and returned it. | RandomOrderingStrategy . Python version . class RandomOrderingStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: list_copy = list.copy() random.shuffle(list_copy) return list_copy . Java version . package edu.def.sp; import java.util.ArrayList; import java.util.Collections; public class RandomOrderingStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { ArrayList&lt;SupportTicket&gt; listCopy = (ArrayList&lt;SupportTicket&gt;) list.clone(); //shuffle the list randomly Collections.shuffle(listCopy); return listCopy; } } . Most of the FIFOOrderingStrategy’s points are applicable here. . In this ordering class, after making a copy of the list by clone, we should shuffle the list because of our ordering way (random). We did it using a class called Collection and its method shuffle(), which shuffled the list and returned it. | BlackHoleStrategy . Python version . class BlackHoleStrategy(TicketOrderingStrategy): def create_ordering(self, list: List[SupportTicket]) -&gt; List[SupportTicket]: return [] . Java version . package edu.def.sp; import java.util.ArrayList; public class BlackHoleStrategy implements TicketOrderingStrategy{ @Override public ArrayList&lt;SupportTicket&gt; createOrdering(ArrayList&lt;SupportTicket&gt; list) { //just return an empty ArrayList return new ArrayList&lt;&gt;(); } } . Most of the FIFOOrderingStrategy’s points are applicable here. . This class returns an empty ArrayList&lt;&gt;() when we’ll need it for any reason. | CustomerSupport . Python version . class CustomerSupport: def __init__(self, processing_strategy: TicketOrderingStrategy): self.tickets = [] self.processing_strategy = processing_strategy def create_ticket(self, customer, issue): self.tickets.append(SupportTicket(customer, issue)) def process_tickets(self): # create the ordered list ticket_list = self.processing_strategy.create_ordering(self.tickets) # if it&#39;s empty, don&#39;t do anything if len(ticket_list) == 0: print(&quot;There are no tickets to process. Well done!&quot;) return # go through the tickets in the list for ticket in ticket_list: self.process_ticket(ticket) def process_ticket(self, ticket: SupportTicket): print(&quot;==================================&quot;) print(f&quot;Processing ticket id: {ticket.id}&quot;) print(f&quot;Customer: {ticket.customer}&quot;) print(f&quot;Issue: {ticket.issue}&quot;) print(&quot;==================================&quot;) . Java version . package edu.def.sp; import java.util.ArrayList; public class CustomerSupport { private ArrayList&lt;SupportTicket&gt; tickets; private TicketOrderingStrategy processingStrategy; CustomerSupport(TicketOrderingStrategy processingStrategy){ tickets = new ArrayList&lt;&gt;(); this.processingStrategy = processingStrategy; } public void createTicket(String customer, String issue){ tickets.add(new SupportTicket(customer, issue)); } public void processTickets(){ ArrayList&lt;SupportTicket&gt; ticketList = this.processingStrategy.createOrdering(this.tickets); if (ticketList.size() == 0){ System.out.println(&quot;There are no tickets to process. Well done!&quot;); return; } for (SupportTicket ticket: ticketList){ this.processTicket(ticket); } } /** * As it has only internal usage, we can define this function as a private one. * @param ticket */ private void processTicket(SupportTicket ticket){ System.out.println(&quot;==================================&quot;); System.out.println(&quot;Processing ticket id: &quot; + ticket.getId()); System.out.println(&quot;Customer: &quot; + ticket.getCustomer()); System.out.println(&quot;Issue: &quot; + ticket.getIssue()); System.out.println(&quot;==================================&quot;); } } . This class is the heart of the application; create customers ArrayList, add tickets to it, process tickets and show them to the user by any request. | We have two private parameters whose value will be assigned to them in the class’s constructor. | In the constructor, we pass an object of the TicketOrderingStrategy interface, which is a non-primitive data type. This object will define the ordering in this class. Also, we are creating a new ArrayList object in this constructor. | In the createTickets () public method, we create a SupportTicket object and add it to the tickets ArrayList. | In the proccessTicket() method, we are ordering the ticket ArrayList by passing this list to the processingStrategy object’s method (createOrdering()). This will return the desired ordered list, and the ticket - ArrayList will be replaced. Then, we will start to print each list entry by passing them to the processTicket() method. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/3-StrategyPattern.html",
            "relUrl": "/markdown/2022/06/19/3-StrategyPattern.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Dependency Inversion in Java",
            "content": "Dependency Inversion principles code translation in Java . Published by Saman Pordanesh . General Introduction . This topic discusses how we can implement some object-oriented definitions like Abstraction or Interfaces in a language like a python which doesn’t have these definitions locally. As Java is a strong OOP language, we already have these definitions for it. We will implement the translation of the video’s code here to understand how these principles work on Java. | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Dependency Inversion lessons in python programming languages (dependency-inversion-after.py) | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.di (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Implementational Instruction . we create one .java file per each class under edu.def.di package. | We are going to discuss Switchable class more here. This class is an interface class and we use the “interface” keyword instead of “class”. But why this is an interface? The answer is that this class just contains the prototypes of methods without any implementation. It is an index which shows a specific structure but can have different functionality when we override it on the child class. Please read about the interface on OOP and interface on java. | When we created other classes (LightBulb.java, Fan.java, ElectricPowerSwitch.java), we need Main.java to contain our main function to run the program. | After that, we will start to translate all classes to their belonging files based on the Python source. We will compare all of them with the original version in the following section. | Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/di/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.di.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . Switchable . Python version . class Switchable(ABC): @abstractmethod def turn_on(self): pass @abstractmethod def turn_off(self): pass . Java version . package edu.def.di; public interface Switchable { void turnOn(); void turnOff(); } . This class is the main lesson for this session, as we are talking about interface and Switchable is an interface class. As we can see, we implemented it with “interface” keyword and it just contains prototype of each method, without any implementation or parameter. | As we don’t have interface in python, this class needs to inherit ABC class to act like an abstract class, although in Java we already have abstract and interface definitions locally. (in python version he used “@abstractmethod” keyword to show that they are abstract methods. Also, there are differences between abstract and interface which recommend learning about them.) | Its child classes will inherit all methods from it, and we will implement all methods at child classes under the “@Override” keyword. | As we talked about it before, we don’t need any implementation for both turnOn and turnOff methods at the interface. | LightBulb . Python version . class LightBulb(Switchable): def turn_on(self): print(&quot;LightBulb: turned on...&quot;) def turn_off(self): print(&quot;LightBulb: turned off...&quot;) . Java version . package edu.def.di; public class LightBulb implements Switchable{ @Override public void turnOn() { System.out.println(&quot;LightBulb: turned on...&quot;); } @Override public void turnOff() { System.out.println(&quot;LightBulb: turned off...&quot;); } } . This is one of the Switchable children which is inheriting all methods from its parent class. | “Implements Switchable” is the keyword for inheritance. | As its obvious, all methods from interface parent are being overriding in this class, although we can have more methods and parameters in this class which don’t have any connection whith the parent class. | Notice that in python version we simply use general inheritance implementation and redefine all methods without any keyword. | Fan . Python version . class Fan(Switchable): def turn_on(self): print(&quot;Fan: turned on...&quot;) def turn_off(self): print(&quot;Fan: turned off...&quot;) . Java version . package edu.def.di; public class Fan implements Switchable{ @Override public void turnOn() { System.out.println(&quot;Fan: turned on...&quot;); } @Override public void turnOff() { System.out.println(&quot;Fan: turned off...&quot;); } } . The same points as LightBulb class. . ElectricPowerSwitch . Python version . class ElectricPowerSwitch: def __init__(self, c: Switchable): self.client = c self.on = False def press(self): if self.on: self.client.turn_off() self.on = False else: self.client.turn_on() self.on = True . Java version . package edu.def.di; public class ElectricPowerSwitch { private Switchable client; private boolean on = false; ElectricPowerSwitch(Switchable client){ this.client = client; } public void press(){ if (on){ client.turnOff(); on = false; } else { client.turnOn(); on = true; } } } . This is a general class with specific functionality to act as an electric device. We will define the kind of device by passing related object to this class (this is an Aggregation relationship. More here). | We have two parameters. The first one (client) is a non-primary data type with type of Switchable and we will define its value on the class constructor. The second one (on) is a primary data type Boolean with a default value of false. In addition a public method press. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/2-DependencyInversion.html",
            "relUrl": "/markdown/2022/06/19/2-DependencyInversion.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Cohesion and Coupling in Java",
            "content": "Cohesion and Coupling principles code translation in Java . Published by Saman Pordanesh . Introduction . Cohesion is used to indicate the degree to which a class has a single, well-focused purpose. Coupling is all about how classes interact with each other; on the other hand, cohesion focuses on how the single class is designed. Higher the cohesiveness of the class, the better is the OO design. Benefits of Higher Cohesion: Highly cohesive classes are much easier to maintain and less frequently changed. | Such classes are more usable than others as they are designed with a well-focused purpose. | . | You need to watch the video first, understand all principles, and then look at the translation codes in Java. This documentation will help you to understand the translation better | This translation is based on the final code source of Cohesion and Coupling lessons in python programming languages (coupling-cohesion-after.py) | We need a separate class with the main function to run the program, despite Python, in which you can run each .py file individually. Main.java is the file with the main function for that purpose. | Standard naming on java is different. You can find more information here. | . Directories changes . This is one of the most significant changes we made to our translation. A Java project with an exact directory with all dependencies can be good practice for OOP designing. | We defined a package name for this project as edu.def.cac (package naming standards) and its specific directory under the src folder. This package name keeps all project components connected to gather when we implement them on different .java files. | However, packages are not necessary, you could use a default package, or even have all classes in the same file; this is more Java best practice. | More information about Java’s project directory standards is here. | . Compiling Instruction . Run the command prompt inside the src folder. | Run the following command to compile all .java files: javac edu/def/cac/*.java . | To execute the program, we should run the Main.java file from the command prompt. To do this, from the same directory, run the following command on the command prompt: java edu.def.cac.Main . If your main function is in a different class, put the name of that class instead of Main at the end of the command . | You can find more about compiling instruction here | . Classes changes . VehicleInfo . Python version . class VehicleInfo: def __init__(self, brand, electric, catalogue_price): self.brand = brand self.electric = electric self.catalogue_price = catalogue_price def compute_tax(self): tax_percentage = 0.05 if self.electric: tax_percentage = 0.02 return tax_percentage * self.catalogue_price def print(self): print(f&quot;Brand: {self.brand}&quot;) print(f&quot;Payable tax: {self.compute_tax()}&quot;) . Java version . package edu.def.cac; /** * A class with 3 private parameters and two public * methods. Also, a constructor with 3 arguments. */ public class VehicleInfo { private String brand; private boolean electric; private int cataloguePrice; VehicleInfo(String brand, boolean electric, int cataloguePrice){ this.brand = brand; this.electric = electric; this.cataloguePrice = cataloguePrice; } /** * * @return a double which is the computed tax. */ public double computeTax(){ double taxPercentage = 0.05; if (electric){ taxPercentage = 0.02; } return taxPercentage * cataloguePrice; } /** * */ public void print(){ System.out.println(&quot;Brand: &quot; + this.brand); System.out.println(&quot;Payable tax: &quot; + this.computeTax()); } } . we defined three private parameters in this class, and their values will be determined by the class instructor when we initialize the class. getters and setters for each private parameter, are not required, you can access fields directly by making parameters public in Java as well, but it’s (private parameters) frequently done in Java as an OOP principle. Still, as we won’t need direct access to any parameters in future, we do not implement them here (it’s acceptable). | Be careful that we specify all data types when we initialize them, although it’s unnecessary for python. | We can add strings together for printing by the “+” sign, although we used formatted string to do that on python. | Vehicle . Python version . class Vehicle: def __init__(self, id, license_plate, info): self.id = id self.license_plate = license_plate self.info = info def print(self): print(f&quot;Id: {self.id}&quot;) print(f&quot;License plate: {self.license_plate}&quot;) self.info.print() . Java version . package edu.def.cac; /** * Public class Vehicle with 3 private parameters * and one public method. Plus a constructor with * 3 arguments. */ public class Vehicle { private String id; private String licensePlate; private VehicleInfo info; Vehicle(String id, String licensePlate, VehicleInfo info){ this.id = id; this.licensePlate = licensePlate; this.info = info; } public void print(){ System.out.println(&quot;Id: &quot; + this.id); System.out.println(&quot;License plate: &quot; + this.licensePlate); this.info.print(); } } . A simple class which has three parameters. As we explained in the previous class, we defined all of them as “private” without any getter and setter. | The same point about joining strings together for printing in the print function. | VehicleRegistry . Python version . class VehicleRegistry: def __init__(self): self.vehicle_info = { } self.add_vehicle_info(&quot;Tesla Model 3&quot;, True, 60000) self.add_vehicle_info(&quot;Volkswagen ID3&quot;, True, 35000) self.add_vehicle_info(&quot;BMW 5&quot;, False, 45000) self.add_vehicle_info(&quot;Tesla Model Y&quot;, True, 75000) def add_vehicle_info(self, brand, electric, catalogue_price): self.vehicle_info[brand] = VehicleInfo(brand, electric, catalogue_price) def generate_vehicle_id(self, length): return &#39;&#39;.join(random.choices(string.ascii_uppercase, k=length)) def generate_vehicle_license(self, id): return f&quot;{id[:2]}-{&#39;&#39;.join(random.choices(string.digits, k=2))}-{&#39;&#39;.join(random.choices(string.ascii_uppercase, k=2))}&quot; def create_vehicle(self, brand): id = self.generate_vehicle_id(12) license_plate = self.generate_vehicle_license(id) return Vehicle(id, license_plate, self.vehicle_info[brand]) . Java version . package edu.def.cac; import java.util.HashMap; import java.util.Random; public class VehicleRegistry { /** * We use HashMap in java when we want to have a data structure as shows Key -&gt; Value * here, the key is the car&#39;s brand and its is a VehicleInfo object */ HashMap&lt;String, VehicleInfo&gt; vehicleInfo = new HashMap&lt;&gt;(); VehicleRegistry(){ //Saturating the HashMap on constructor this.addVehicleInfo(&quot;Tesla Model 3&quot;, true, 60000); this.addVehicleInfo(&quot;Volkswagen ID3&quot;, true, 35000); this.addVehicleInfo(&quot;BMW 5&quot;, false, 45000); this.addVehicleInfo(&quot;Tesla Model Y&quot;, true, 75000); } public void addVehicleInfo(String brand, boolean electric, int cataloguePrice){ /*create an entry for the HashMap which the Key is String type and the Vale is a non-primary data type VehicleInfo */ this.vehicleInfo.put(brand, new VehicleInfo(brand, electric, cataloguePrice)); } public String generateVehicleId(int length){ return getSaltString(&quot;uppercase&quot;, length); } public String generateVehicleLicense(String id){ return id.substring(0, 2) + &quot;-&quot; + getSaltString(&quot;digits&quot;, 2) + &quot;-&quot; + getSaltString(&quot;uppercase&quot;, 2); } public Vehicle createVehicle(String brand){ String id = generateVehicleId(12); String licensePlate = generateVehicleLicense(id); return new Vehicle(id, licensePlate, vehicleInfo.get(brand)); } /** * As we dont have a simple function to arrange a random string on Java, we are implementing * this helper method to help us create one. * It acts like &quot;random.choices&quot; in Python * @param ascii * @return */ protected String getSaltString(String ascii, int length) { //char sets based on the incoming argument String SALTCHARS; switch (ascii){ case &quot;uppercase&quot;: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; break; case &quot;lowercase&quot;: SALTCHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;; break; case &quot;digits&quot;: SALTCHARS = &quot;1234567890&quot;; break; default: SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; } StringBuilder salt = new StringBuilder(); Random rnd = new Random(); while (salt.length() &lt; length) { // length of the random string. int index = (int) (rnd.nextFloat() * SALTCHARS.length()); salt.append(SALTCHARS.charAt(index)); } return salt.toString(); } } . In this class, we are using vehicleInfo HashMap as an alternative data structure for Python’s dictionary. HashMap is a data structure which allows us to define a key for a specific value and get access to that value with the key in future (key -&gt; value). In this class, we use a car’s brand as a key and attach it to belonging vehicle information (value). As a result, we will be able to access each car’s brand information through key -&gt; value. In addition, this parameter is a private one. | ` `We initialized vehicleInfo with some data at the class construction VehicleRegistry. This isn’t a good and professional way to saturate a hash map, but it works in this example just for educational purposes. | The function addVehicleInfo is for adding new data to the vehicleInfo HashMap by getting three arguments. The first argument will be the key on the HashMap, and the others will be used to initialize an object from VehicleInfo class. As you can see, vehicleInfo.put(key, value) is a function to add an entry to the HashMap. | At the function generateVicleId, we see a significant difference between the Java version and the Python one. We need to define the getSaltString helper method to generate random strings based on the three categories of ASCII characters (uppercase, lowercase, digits). However, we already have a predefined function to do this in Python. In this function, we need to return a random string of uppercase characters with the size of length, which is the function’s argument. . | At generateVehicleLicense, we create a specific string format. By the substring() method, we can split a particular part of a string. It’s identical to Python’s string[start, end] method. | As we said before, getSaltString is a helper method to generate random strings based on specific size and type. You can find more here. | Application . Python version . class Application: def register_vehicle(self, brand: string): # create a registry instance registry = VehicleRegistry() vehicle = registry.create_vehicle(brand) # print out the vehicle information vehicle.print() . Java version . package edu.def.cac; public class Application { /** * to put all different components togather and create an application for a specific brand of car. * @param brand: main input to create an application. */ public void registerVehicle(String brand){ VehicleRegistry registry = new VehicleRegistry(); Vehicle vehicle = registry.createVehicle(brand); vehicle.print(); } } . This class, with a simple public function, is created to put all other classes and their method together to lunch an application. The only argument that the registerVehicle method needs is a car’s brand string. |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2022/06/19/1-CohesionAndCoupling.html",
            "relUrl": "/markdown/2022/06/19/1-CohesionAndCoupling.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Federated Learning (Data Scientist)",
            "content": "Published by by Leo Wei . Table of Contents: . What is federated learning? Tools that made federated learning possible | . | Installation | Pysyft Duet (Data scientist) Duet Basics | MNIST with Duet Part 1: Connect to Remote Duet Server | Part 2: Setting up Model and Data | Part 3: Training | Part 4: Inference | . | . | Where to next | . What is federated learning? . In the world of evergrowing data in every industry, data is becoming more scarce due to security and privacy reasons. This makes our jobs as data scientists harder as companies and institutions are holding on to their data for security and competitive reasons. Furthermore, a lot of important data these days are sensitive personal information, things like health, and happiness, etc. Our ability to solve problems is limited because we can&#39;t access the existing data. . Federated learning is a machine learning setting where multiple clients(data owners) can come together and solve a machine learning problem, under the coordination of a central server(data scientist). Each data owner&#39;s data is stored locally, and will not be access without direct permission. Instead of traditionally training on one machine locally, the network is sent to all clients and trained on multiple clients simultaneously. After training, the machine learning model would aggregate the model updates from the trained model from the clients. . There are many situations in which this is the case. One use case of this is in the case with federated learning in the healthcare industry: Breast cancer is a something that is faced by 1 in 8 woman. It is actually a very treatable if it is detected early enough in a mamography. However, this is where the problem lies. In detection, there is a 1 in 4 chance that the radiologist saying that it is false positive or false negative, and with AI, the detection accuracy is even worse with the accuracy being 1 in 3 false positive or false negative. This is most likely due to our models not having enough training data, the amount of training data we have is less than &lt;0.1% of the world&#39;s mamography images. These data that we need are stored across thousands of organizations, and acquiring data from each organization is extremely difficult as some organizations will protect patient&#39;s privacy not mentioning the bureaucracy involved in signing contracts and risk management with thousands of different companies and organizations. . Federated learning could tackle this problem by having a massive federated data network, each data center(hospital, research center, etc) would act as a client. We, as the data scientist is able to send our machine learning model to each client, and have the client train the model locally, and finally update the global model by exchanging the weighted average of the weights. (FedAvg Algorithm) . . Advantage of federated learning . Data never leaves the owner&#39;s device, privacy of sentitive data is stored. | Federated learning allows devices like cell phones to train collectively, thus saving computation and memory on the server, data scientist&#39;s side. | Data owners are more comfortable with sharing their data, and leading to better machine learning models. | . Limitations of federated learning . Communication, latency is often the bottleneck for federated learning. | Variability in client hardware, it is often the case that after each round of training, the server will have to wait for the slower devices to report back with their trained weights. These stragglers often slows down the network, often times, the network just drop the stragglers, but is that a good approach? Does that mean the model will cater more towards people with faster phones? | . Tools that made federated learning possible . 1. Remote execution . Remote execution is a core tool used in federated learning. Instead of downloading the data from the clients and then perform machine learning on it, remote execution allows you to use the client&#39;s data without their data leaving their devices. . 2. Search and example data . If we are executing functions remotely, how can we do data science without seeing the data? With tools such as sample data, we can feature engineer the data without actually seeing the full data. We can request from the data owners to allow us to see a small sub sample of the data in order for us to get a better understanding of the data. . 3. Differential privacy . How do we query again a database without revealing too much information about its privacy data? Our goal is to achieve perfect privacy, meaning that the output of our query is the same between this database and any identical database with one row removed or replaced. However, achieving this is incredibly difficult and the way in which we attempt to achieve this is by adding a certain level of noise to the data. . 4. Secure multi-party computation . The idea of secure multi-party computation is that multiple people can combine their private inputs to compute a function, without revealing their inputs to each other. . In the following example, we will look at one of the most popular library for federated learning Pysyft. Developed by openmined, pysyft was developed with the goal of secure and private machine learning. The Pysyft library is meant for you to write code that is capable of computing on data not owned on your local machine. In the following demo, we will be exploring the tool of remote execution. . Installation . Before we dive into federated learning, let&#39;s install the necessary packages. . 1. Install Conda environment . conda create --name duet python=3.8 Don&#39;t forget to activate your environment conda activate duet . 2. Install necessary packages . Inside your folder, create a txt file named &#39;requirements.txt&#39; Then copy and past the following inside the txt file numpy aiortc cryptography dataclasses dpcontracts flask forbiddenfruit&gt;=0.1.3 loguru matplotlib nest_asyncio packaging pandas protobuf pydagogy PyNaCl requests scikit-learn seaborn sqlitedict statsmodels typeguard typing-extensions # backport to older python 3 websockets jupyter Jinja2&lt;3.0 Afterwards, we can install the requirements by running the following command . pip install -r requirements.txt . 3. Install Pysyft . pip install syft==0.5.0 . If you have errors . ImportError: cannot import name &#39;soft_unicode&#39; from &#39;markupsafe&#39; Resolve this by python -m pip install markupsafe==2.0.1 | If you have the warning of CrytographyDeprecationWarning, you can ignore it for now. | . Pysyft Duet (Data Scientist) . A peer-to-peer tool developed on top of the PySyft. It allows the data owner to expose their data to the data scientist, and the data scientist can manipulate the data through a zero-knowledge access mechanism. As data owners, you have the right to decide whether to allow the manipulation of data, you can deny or approve requests from the data scientists. As data scientists, you can develop new insights and train your model using the data owned by the data owners. . Duet was used to demonstrate federated learning with PySyft without being deployed in the PyGrid ecosystem. . To start, both the data owner and the data scientist will have to talk to one of the open grid network nodes hosted on AWS by OpenMined. The node will introduce the service to each other behind a firewall and help them connect peer to peer. . | The data owner need to first connect initiate and launch the duet server. . | With the server ID, the data scientist can join the duet session. This will give the data scientist a duet client id. . | The data owner will then need to enter the client id to complete the setup process. . | If all goes well, the data scientist and the data owner should be connected now. . | Duet Basics . As the Data Scientist, you want to perform data science on data that is sitting in the Data Owner&#39;s Duet server in their Notebook. . In order to do this, we must run the code that the Data Owner sends us, which importantly includes their Duet Session ID. The code will look like this, importantly with their real Server ID. . import syft as sy duet = sy.duet(&#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39;) This will create a direct connection from my notebook to the remote Duet server. Once the connection is established all traffic is sent directly between the two nodes. . Paste the code or Server ID that the Data Owner gives you and run it in the cell below. It will return your Client ID which you must send to the Data Owner to enter into Duet so it can pair your notebooks. . Make sure that the network_url you use is chosen from https://raw.githubusercontent.com/OpenMined/OpenGridNodes/master/network_address . import syft as sy duet = sy.join_duet(&quot;00eec93acc58f144d78a365705d42223&quot;, network_url=&quot;http://ec2-18-218-7-180.us-east-2.compute.amazonaws.com:5000/&quot;) . 🎤 🎸 ♪♪♪ Joining Duet ♫♫♫ 🎻 🎹 ♫♫♫ &gt; DISCLAIMER: Duet is an experimental feature currently in beta. ♫♫♫ &gt; Use at your own risk. &gt; ❤️ Love Duet? Please consider supporting our community! &gt; https://github.com/sponsors/OpenMined ♫♫♫ &gt; Punching through firewall to OpenGrid Network Node at: ♫♫♫ &gt; http://ec2-18-218-7-180.us-east-2.compute.amazonaws.com:5000/ ♫♫♫ &gt; ♫♫♫ &gt; ...waiting for response from OpenGrid Network... ♫♫♫ &gt; DONE! ♫♫♫ &gt; STEP 1: Send the following Duet Client ID to your duet partner! ♫♫♫ &gt; Duet Client ID: 3406364123dfde0c6e7394b2167a9ef9 ♫♫♫ &gt; ...waiting for partner to connect... . /opt/anaconda3/envs/duet/lib/python3.9/site-packages/aiortc/rtcdtlstransport.py:211: CryptographyDeprecationWarning: This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now. _openssl_assert(lib.SSL_CTX_use_certificate(ctx, self._cert._x509) == 1) # type: ignore /opt/anaconda3/envs/duet/lib/python3.9/site-packages/aiortc/rtcdtlstransport.py:186: CryptographyDeprecationWarning: This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now. value=certificate_digest(self._cert._x509), # type: ignore . ♫♫♫ &gt; CONNECTED! . The duet variable is your reference to remote operations including supported libraries like torch. . We can search for available data with their meta data(tags, decription and object type) with the following: . duet.store.pandas . ID Tags Description object_type . 0 &lt;UID: 2550b41ead684a24ac87a5dced4c5c6d&gt; | [grades] | This is a list of the grades of 6 people | &lt;class &#39;torch.Tensor&#39;&gt; | . We can create a pointer to the data in the duet store. Note that this is the reference to the data, not the actual data. . data_ptr = duet.store[0] . Now, let&#39;s do some computation remotely . average_grade = data_ptr.float().mean() . After we have done the computation, let&#39;s try and get the result from the data owner&#39;s server. . try: average_grade.get() except Exception: print(Exception) . [2022-06-19T16:37:24.260967-0600][CRITICAL][logger]][15013] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. . &lt;class &#39;Exception&#39;&gt; . Oh no, looks like we need to request for permission from the data owner. We can do this by using the .request with your reasoning inside. . average_grade.request(reason = &quot;please, I need it&quot;) . try: average_grade.get() except Exception: print(Exception) . [2022-06-19T16:37:35.877293-0600][CRITICAL][logger]][15013] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. . &lt;class &#39;Exception&#39;&gt; . Looks like our request didn&#39;t go through, let&#39;s create a new request with a better reasoning. . average_grade.request( reason = &quot;I am a data scientist and I need to know the average of the students&#39; grades for my analysis&quot; ) . We can check if there are still outstanding requests by running the following block . duet.requests.pandas . . Looks like our request went through, now let&#39;s get the data . avg = average_grade.get() print(avg) . tensor(81.1667) . MNIST with Duet . Part 1: Connect to Remote Duet Server (Done above) . Part 2: Setting up Model and Data . import torch import torchvision . Note that here, instead of traditionally inheriting from the nn.Module, we inherit from sy.Module, and we also need to pass in a variable called torch_ref when we constuct this network, the torch_ref will be used internally for any calls that would normally be to torch. . class SyNet(sy.Module): def __init__(self, torch_ref): super(SyNet, self).__init__(torch_ref=torch_ref) self.conv1 = self.torch_ref.nn.Conv2d(1, 32, 3, 1) self.conv2 = self.torch_ref.nn.Conv2d(32, 64, 3, 1) self.dropout1 = self.torch_ref.nn.Dropout2d(0.25) self.dropout2 = self.torch_ref.nn.Dropout2d(0.5) self.fc1 = self.torch_ref.nn.Linear(9216, 128) self.fc2 = self.torch_ref.nn.Linear(128, 10) def forward(self, x): x = self.conv1(x) x = self.torch_ref.nn.functional.relu(x) x = self.conv2(x) x = self.torch_ref.nn.functional.relu(x) x = self.torch_ref.nn.functional.max_pool2d(x, 2) x = self.dropout1(x) x = self.torch_ref.flatten(x, 1) x = self.fc1(x) x = self.torch_ref.nn.functional.relu(x) x = self.dropout2(x) x = self.fc2(x) output = self.torch_ref.nn.functional.log_softmax(x, dim=1) return output . local_model = SyNet(torch) . args = { &quot;batch_size&quot;: 64, &quot;test_batch_size&quot;: 1000, &quot;epochs&quot;: 3, &quot;lr&quot;: 0.01, &quot;gamma&quot;: 0.7, &quot;no_cuda&quot;: False, &quot;dry_run&quot;: False, &quot;seed&quot;: 42, &quot;log_interval&quot;: 10, &quot;save_model&quot;: True, } . Now we can send our local model to our partner&#39;s Duet server . model = local_model.send(duet) . We can create an alias for our partner&#39;s torch called remote_torch, we do this so we can refer to the local torch as torch and any operations we want to do remotely as remote_torch. Remeber that the return values from remote_torch are Pointers, not the actual objects themselves. Keep in mind that you cannot mix the pointers with local torch objects. . remote_torch = duet.torch . has_cuda = False has_cuda_ptr = remote_torch.cuda.is_available() has_cuda = bool(has_cuda_ptr.get( request_block=True, reason=&quot;To run test and inference locally&quot;, timeout_secs=20, # change to something slower )) print(has_cuda) use_cuda = not args[&quot;no_cuda&quot;] and has_cuda # now we can set the seed remote_torch.manual_seed(args[&quot;seed&quot;]) device = remote_torch.device(&quot;cuda&quot; if use_cuda else &quot;cpu&quot;) print(f&quot;Data Owner device is {device.type.get()}&quot;) . False Data Owner device is cpu . if has_cuda: model.cuda(device) else: model.cpu() . Get parameters, setup an optimizer and scheduler just like you would do in Pytorch . params = model.parameters() . optimizer = remote_torch.optim.Adadelta(params, lr=args[&quot;lr&quot;]) . scheduler = remote_torch.optim.lr_scheduler.StepLR(optimizer, step_size=1, gamma=args[&quot;gamma&quot;]) . Next we need a training loop so we can improve our remote model. Since we want to train on remote data we should first check if the model is remote since we will be using remote_torch in this function. To check if a model is local or remote simply use the .is_local attribute. . def train(model, torch_ref, train_loader, optimizer, epoch, args, train_data_length): # + 0.5 lets us math.ceil without the import train_batches = round((train_data_length / args[&quot;batch_size&quot;]) + 0.5) print(f&quot;&gt; Running train in {train_batches} batches&quot;) if model.is_local: print(&quot;Training requires remote model&quot;) return model.train() for batch_idx, data in enumerate(train_loader): data_ptr, target_ptr = data[0], data[1] optimizer.zero_grad() output = model(data_ptr) loss = torch_ref.nn.functional.nll_loss(output, target_ptr) loss.backward() optimizer.step() loss_item = loss.item() train_loss = duet.python.Float(0) # create a remote Float we can use for summation train_loss += loss_item if batch_idx % args[&quot;log_interval&quot;] == 0: local_loss = None local_loss = loss_item.get( reason=&quot;To evaluate training progress&quot;, request_block=True, timeout_secs=5 ) if local_loss is not None: print(&quot;Train Epoch: {} {} Loss: {:.4}&quot;.format(epoch, batch_idx, local_loss)) else: print(&quot;Train Epoch: {} {} ?&quot;.format(epoch, batch_idx)) if batch_idx &gt;= train_batches - 1: print(&quot;batch_idx &gt;= train_batches, breaking&quot;) break if args[&quot;dry_run&quot;]: break . def test_local(model, torch_ref, test_loader, test_data_length): # download remote model if not model.is_local: local_model = model.get( request_block=True, reason=&quot;test evaluation&quot;, timeout_secs=5 ) else: local_model = model # + 0.5 lets us math.ceil without the import test_batches = round((test_data_length / args[&quot;test_batch_size&quot;]) + 0.5) print(f&quot;&gt; Running test_local in {test_batches} batches&quot;) local_model.eval() test_loss = 0.0 correct = 0.0 with torch_ref.no_grad(): for batch_idx, (data, target) in enumerate(test_loader): output = local_model(data) iter_loss = torch_ref.nn.functional.nll_loss(output, target, reduction=&quot;sum&quot;).item() test_loss = test_loss + iter_loss pred = output.argmax(dim=1) total = pred.eq(target).sum().item() correct += total if args[&quot;dry_run&quot;]: break if batch_idx &gt;= test_batches - 1: print(&quot;batch_idx &gt;= test_batches, breaking&quot;) break accuracy = correct / test_data_length print(f&quot;Test Set Accuracy: {100 * accuracy}%&quot;) . local_transform_1 = torchvision.transforms.ToTensor() # this converts PIL images to Tensors local_transform_2 = torchvision.transforms.Normalize(0.1307, 0.3081) # this normalizes the dataset # compose our transforms local_transforms = torchvision.transforms.Compose([local_transform_1, local_transform_2]) from syft.util import get_root_data_path # we will configure the test set here locally since we want to know if our Data Owner&#39;s # private training dataset will help us reach new SOTA results for our benchmark test set test_kwargs = { &quot;batch_size&quot;: args[&quot;test_batch_size&quot;], } test_data = torchvision.datasets.MNIST(str(get_root_data_path()), train=False, download=True, transform=local_transforms) test_loader = torch.utils.data.DataLoader(test_data,**test_kwargs) test_data_length = len(test_loader.dataset) print(test_data_length) . 10000 . remote_torchvision = duet.torchvision transform_1 = remote_torchvision.transforms.ToTensor() # this converts PIL images to Tensors transform_2 = remote_torchvision.transforms.Normalize(0.1307, 0.3081) # this normalizes the dataset remote_list = duet.python.List() # create a remote list to add the transforms to remote_list.append(transform_1) remote_list.append(transform_2) # compose our transforms transforms = remote_torchvision.transforms.Compose(remote_list) # The DO has kindly let us initialise a DataLoader for their training set train_kwargs = { &quot;batch_size&quot;: args[&quot;batch_size&quot;], } train_data_ptr = remote_torchvision.datasets.MNIST(str(get_root_data_path()), train=True, download=True, transform=transforms) train_loader_ptr = remote_torch.utils.data.DataLoader(train_data_ptr,**train_kwargs) . # so we can pass that to our training loop and know when to stop def get_train_length(train_data_ptr): train_data_length = len(train_data_ptr) return train_data_length try: if train_data_length is None: train_data_length = get_train_length(train_data_ptr) except NameError: train_data_length = get_train_length(train_data_ptr) print(f&quot;Training Dataset size is: {train_data_length}&quot;) . Training Dataset size is: 60000 . Part 3: Training . import time #args[&quot;dry_run&quot;] = True # comment to do a full train print(&quot;Starting Training&quot;) for epoch in range(1, args[&quot;epochs&quot;] + 1): epoch_start = time.time() print(f&quot;Epoch: {epoch}&quot;) # remote training on model with remote_torch train(model, remote_torch, train_loader_ptr, optimizer, epoch, args, train_data_length) # local testing on model with local torch test_local(model, torch, test_loader, test_data_length) scheduler.step() epoch_end = time.time() print(f&quot;Epoch time: {int(epoch_end - epoch_start)} seconds&quot;) if args[&quot;dry_run&quot;]: break print(&quot;Finished Training&quot;) . if args[&quot;save_model&quot;]: model.get( request_block=True, reason=&quot;test evaluation&quot;, timeout_secs=5 ).save(&quot;./duet_mnist.pt&quot;) . Part 4: Inference . Now we can use our model to do inference either remotely or locally. . import matplotlib.pyplot as plt def draw_image_and_label(image, label): fig = plt.figure() plt.tight_layout() plt.imshow(image, cmap=&quot;gray&quot;, interpolation=&quot;none&quot;) plt.title(&quot;Ground Truth: {}&quot;.format(label)) def prep_for_inference(image): image_batch = image.unsqueeze(0).unsqueeze(0) image_batch = image_batch * 1.0 return image_batch . def classify_local(image, model): if not model.is_local: print(&quot;model is remote try .get()&quot;) return -1, torch.Tensor([-1]) image_tensor = torch.Tensor(prep_for_inference(image)) output = model(image_tensor) preds = torch.exp(output) local_y = preds local_y = local_y.squeeze() pos = local_y == max(local_y) index = torch.nonzero(pos, as_tuple=False) class_num = index.squeeze() return class_num, local_y . def classify_remote(image, model): if model.is_local: print(&quot;model is local try .send()&quot;) return -1, remote_torch.Tensor([-1]) image_tensor_ptr = remote_torch.Tensor(prep_for_inference(image)) output = model(image_tensor_ptr) preds = remote_torch.exp(output) preds_result = preds.get( request_block=True, reason=&quot;To see a real world example of inference&quot;, timeout_secs=10 ) if preds_result is None: print(&quot;No permission to do inference, request again&quot;) return -1, torch.Tensor([-1]) else: # now we have the local tensor we can use local torch local_y = torch.Tensor(preds_result) local_y = local_y.squeeze() pos = local_y == max(local_y) index = torch.nonzero(pos, as_tuple=False) class_num = index.squeeze() return class_num, local_y . import random total_images = test_data_length # 10000 index = random.randint(0, total_images) print(&quot;Random Test Image:&quot;, index) count = 0 batch = index // test_kwargs[&quot;batch_size&quot;] batch_index = index % int(total_images / len(test_loader)) for tensor_ptr in test_loader: data, target = tensor_ptr[0], tensor_ptr[1] if batch == count: break count += 1 print(f&quot;Displaying {index} == {batch_index} in Batch: {batch}/{len(test_loader)}&quot;) if batch_index &gt; len(data): batch_index = 0 image_1 = data[batch_index].reshape((28, 28)) label_1 = target[batch_index] draw_image_and_label(image_1, label_1) . Random Test Image: 1192 Displaying 1192 == 192 in Batch: 1/10 . class_num, preds = classify_remote(image_1, model) print(f&quot;Prediction: {class_num} Ground Truth: {label_1}&quot;) print(preds) . Prediction: 4 Ground Truth: 9 tensor([1.3907e-04, 5.6652e-04, 2.7458e-04, 4.1249e-03, 7.1542e-01, 3.2733e-03, 2.5919e-03, 2.5418e-02, 2.2922e-02, 2.2527e-01], grad_fn=&lt;SqueezeBackward0&gt;) . local_model = model.get( request_block=True, reason=&quot;To run test and inference locally&quot;, timeout_secs=5, ) . class_num, preds = classify_local(image_1, local_model) print(f&quot;Prediction: {class_num} Ground Truth: {label_1}&quot;) # here we can see the actual output print(preds) . Prediction: 4 Ground Truth: 9 tensor([0.0020, 0.0041, 0.0078, 0.0385, 0.2883, 0.1381, 0.0244, 0.0568, 0.2300, 0.2100], grad_fn=&lt;SqueezeBackward0&gt;) . from PIL import Image, ImageEnhance import PIL.ImageOps import os def classify_url_image(image_url): filename = os.path.basename(image_url) os.system(f&#39;curl -O {image_url}&#39;) im = Image.open(filename) im = PIL.ImageOps.invert(im) # im = im.resize((28,28), Image.ANTIALIAS) im = im.convert(&#39;LA&#39;) enhancer = ImageEnhance.Brightness(im) im = enhancer.enhance(3) print(im.size) fig = plt.figure() plt.tight_layout() plt.imshow(im, cmap=&quot;gray&quot;, interpolation=&quot;none&quot;) # classify local class_num, preds = classify_local(image_1, local_model) print(f&quot;Prediction: {class_num}&quot;) print(preds) . image_url = &quot;https://raw.githubusercontent.com/kensanata/numbers/master/0018_CHXX/0/number-100.png&quot; classify_url_image(image_url) . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 . (89, 93) Prediction: 4 tensor([0.0007, 0.0016, 0.0049, 0.0291, 0.4118, 0.0332, 0.0071, 0.0289, 0.0928, 0.3899], grad_fn=&lt;SqueezeBackward0&gt;) . 100 4655 100 4655 0 0 3819 0 0:00:01 0:00:01 --:--:-- 3840 . Where to go next? . https://courses.openmined.org/ Openmined(PySyft). This is where I learned most of the federated learning material, and they have a great series on private AI technologies. Highly recommend. . | https://flower.dev/ Flower Another federated learning framework. . | https://www.tensorflow.org/federated Tensorflow Federated. Integrates very nicely with Tensorflow. | . Acknowledgement . I would like this last section by thanking the support of my professor Yves Pauchard, and the DE Followship group. As well as the openmined for innovating and building technology for the future, their work has inspired me to pursue more research and learning in the field of federated learning and I am extremely thankful. .",
            "url": "https://de-fellows.github.io/RexCoding/2022/06/09/MNIST_Data_Scientist.html",
            "relUrl": "/2022/06/09/MNIST_Data_Scientist.html",
            "date": " • Jun 9, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Federated Learning (Data Owner)",
            "content": "Published by by Leo Wei . Before reading the rest of this blog, make sure you read the Federated Learning (Data Scientist). Or have both of them open side by side. . Pysyft Duet (Data Owner) . As a data owner, you want someone lese to perform data science on data that you own that want to protect. To do this, we can load our data into our local duet server. To begin the process, you must launch a Duet session and help your Duet partner (data scientist) connect to this server. . Duet Basics . Make sure that the network_url you use is chosen from https://raw.githubusercontent.com/OpenMined/OpenGridNodes/master/network_address . import syft as sy duet = sy.launch_duet(network_url=&quot;http://ec2-18-218-7-180.us-east-2.compute.amazonaws.com:5000&quot;) . 🎤 🎸 ♪♪♪ Starting Duet ♫♫♫ 🎻 🎹 ♫♫♫ &gt; DISCLAIMER: Duet is an experimental feature currently in beta. ♫♫♫ &gt; Use at your own risk. &gt; ❤️ Love Duet? Please consider supporting our community! &gt; https://github.com/sponsors/OpenMined ♫♫♫ &gt; Punching through firewall to OpenGrid Network Node at: ♫♫♫ &gt; http://ec2-18-218-7-180.us-east-2.compute.amazonaws.com:5000 ♫♫♫ &gt; ♫♫♫ &gt; ...waiting for response from OpenGrid Network... ♫♫♫ &gt; DONE! ♫♫♫ &gt; Duet Server ID: 00eec93acc58f144d78a365705d42223 ♫♫♫ &gt; STEP 1: Send the following code to your Duet Partner! import syft as sy duet = sy.duet(&#34;00eec93acc58f144d78a365705d42223&#34;) ♫♫♫ &gt; STEP 2: Ask your partner for their Client ID and enter it below! ♫♫♫ &gt; Duet Partner&#39;s Client ID: 3406364123dfde0c6e7394b2167a9ef9 ♫♫♫ &gt; Connecting... . /opt/anaconda3/envs/duet/lib/python3.9/site-packages/aiortc/rtcdtlstransport.py:211: CryptographyDeprecationWarning: This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now. _openssl_assert(lib.SSL_CTX_use_certificate(ctx, self._cert._x509) == 1) # type: ignore /opt/anaconda3/envs/duet/lib/python3.9/site-packages/aiortc/rtcdtlstransport.py:186: CryptographyDeprecationWarning: This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now. value=certificate_digest(self._cert._x509), # type: ignore . ♫♫♫ &gt; CONNECTED! ♫♫♫ &gt; DUET LIVE STATUS * Objects: 18 Requests: 0 Messages: 159124 Request Handlers: 1 . Let&#39;s upload some data to the Duet server . import torch as th . grade_data = th.tensor([98, 78, 83, 88, 67, 73]) grade_data = grade_data.tag(&quot;grades&quot;) grade_data = grade_data.describe(&quot;This is a list of the grades of 6 people&quot;) . # server, note that the data is still on the owner&#39;s machine and cannot be viewed or access # without the permission from the data owner grade_data_pointer = grade_data.send(duet, pointable = True) . [2022-06-19T16:37:24.257117-0600][CRITICAL][logger]][15016] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. [2022-06-19T16:37:24.258016-0600][CRITICAL][logger]][15016] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. . duet.requests.pandas . Requested Object&#39;s tags Reason Request ID Requested Object&#39;s ID Requested Object&#39;s type . 0 [grades, float, mean] | please, I need it | &lt;UID: 16cb1d6c39024a87acf1a29dd1f3d9d7&gt; | &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt; | | . duet.requests[0].deny() . [2022-06-19T16:37:35.873523-0600][CRITICAL][logger]][15016] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. [2022-06-19T16:37:35.874204-0600][CRITICAL][logger]][15016] You do not have permission to .get() Object with ID: &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt;Please submit a request. . duet.requests.pandas . Requested Object&#39;s tags Reason Request ID Requested Object&#39;s ID Requested Object&#39;s type . 0 [grades, float, mean] | I am a data scientist and I need to know the a... | &lt;UID: 1faa4d8b428748f3840271919a750a5b&gt; | &lt;UID: 0e6d0efcb06441db9d958e2006f5cbc8&gt; | | . duet.requests[0].request_description . &#34;I am a data scientist and I need to know the average of the students&#39; grades for my analysis&#34; . duet.requests[0].accept() . MNIST with Duet . Part 1: Launch a Duet Server and Connect (Done above) . Part 2: Get data . from syft.util import get_root_data_path import torchvision torchvision.datasets.MNIST(get_root_data_path(), train=True, download=True, transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(), torchvision.transforms.Normalize((0.1307,), (0.3081,))])) torchvision.datasets.MNIST(get_root_data_path(), train=False, download=True, transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(), torchvision.transforms.Normalize((0.1307,), (0.3081,))])) . Dataset MNIST Number of datapoints: 10000 Root location: /Users/leowei/.syft/data Split: Test StandardTransform Transform: Compose( ToTensor() Normalize(mean=(0.1307,), std=(0.3081,)) ) . Part 2: Add Request Handlers . duet.requests.pandas . . duet.store.pandas # duet.requests.add_handler(action = &quot;deny&quot;) . ID Tags Description object_type . 0 &lt;UID: 2550b41ead684a24ac87a5dced4c5c6d&gt; | [grades] | This is a list of the grades of 6 people | &lt;class &#39;torch.Tensor&#39;&gt; | . duet.requests.add_handler(action=&quot;accept&quot;) . /opt/anaconda3/envs/duet/lib/python3.9/site-packages/syft/lib/torch/uppercase_tensor.py:30: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won&#39;t be populated during autograd.backward(). If you indeed want the gradient for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. grad = getattr(obj, &#34;grad&#34;, None) .",
            "url": "https://de-fellows.github.io/RexCoding/2022/06/09/MNIST_Data_Owner.html",
            "relUrl": "/2022/06/09/MNIST_Data_Owner.html",
            "date": " • Jun 9, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Reinforcement Learning for Engineers in a Hurry",
            "content": "What is Reinforcement Learning? . Reinforcement Learning (RL) in the context of Machine Learning (ML) is one of the three fundamental ML paradigms. . . To properly answer this question, we first need to dive into the different aspects of RL. . Herein, we will use certain terminology to discuss the nature of RL. It is crucial to understand their meanings and how they distunguish RL from the other branches of ML. To get things started, we will present the notion of an agent existing in an environment. . An environment in the relevant context refers to a space - not necessarily a physical one - that exists and can be interacted with. Interactions with such an environment are called actions and should produce some sort of response that can be percieved by anything existing in that environment. . An agent exists in an environment and is able to percieve it, meaning that any response that the environment produces can be experienced by the agent. More specifically, an intelligent agent (IA) is one who takes non-random actions based on feedback from an environment. This feedback comes in the form of two notions, state and reward, which we will discuss more later. An IA takes said actions in order to reach some desirable end result. They may exhibit learning by adjusting their actions over time, or memory by using past experiences in an environment to adjust their current actions. . Putting these concepts together, RL involves an agent learning to take actions in an environment to reach some goal. . Making a Move . For the purpose of RL, it is necessary to have actions performed in a controlled and measurable manner so that we may use information produced by the environment for the benefit of learning. This is where our step function comes into play. A step function can be thought of as the process of taking an action, and recieving a response. It is best summarized in a diagram. . . We see the aforementioned terms state and reward appearing in this flowchart. The state of the environment embodies some variable that describes the environment and changes over time. For example, humidity may be a state variable of the atmosphere. The reward is some feedback from the environment that characterizes the action taken by the agent. A desirable action outcome recieves a positive reward, while an undesireable outcome recieves a negative reward. . An agent chooses to take an action A on the environment at time t based on the current state S at that same time t. The current action A applied on the environment results in a new state produced at time t+1. As we &#39;take a step,&#39; The new state becomes the current, producing a certain action. The cycle repeats, each being called a step. This results in a continuous feedback loop that allows the agent to exist meaningfully. . Decisions, Decisions . The pertinent question still remains, how does an IA make decisions, or learn to do so? Noteably in the previous section, we had little to say about the reward aspect of the flowchart. This reward is what teaches our IA to make certain decisions. . The &#39;brain&#39; of the IA is the policy network. In essence, this is a mathematical function that takes a set of inputs and maps them to an output space. This function has parameters that can be changed to produce different outputs for a given input set. We can exploit this relationship if we are able to determine how to tune these parameters such that the mapping function always leads our IA to the best output based on its inputs. This is the concept of learning. . More specifically, in RL an IA learns to tune these parameters so that it always makes the best choice for a given environment state. The notion of &#39;best&#39; is where our reward comes in. If an IA recieves a positive reward for an action performed due to an input state, we tune the policy network&#39;s parameters such that the IA is a bit more likely to produce the same action the next time that state comes around. If an IA recieves a negative reward (penalty), we do the opposite and tune so that it is less likely to repeat this behaviour. . The &#39;tuning&#39; process is a vastly complex topic that need not be explained here to grasp the idea of RL. It suffices to know why this tuning happens and how it affects the IA&#39;s behaviour. . The Brain . For the purpose of this tutorial, we will use a Neural Network (NN) as the policy network for our IA. . . Neural networks reflect the way that biological brains are designed (in a very simplified manner, that is). Once again, NNs are realtively complex and will not be explained here, but it suffices to know that they fit the role of a policy network. The NN has tunable parameters (weights, biases), an input layer (for our state) and an output layer (for our action). The weights and biases will be varied according to the reward recieved during learning. . Putting the Pieces Together . All in all, we end up with a diagram that looks like the following. . . The NN takes actions based on the state. When learning, the reward updates the parameters of the NN. . Something to note is that when the agent is not learning, the rewards are out the picture. Rewards are only present when learning, and otherwise, our agent is only able to see the state of the environment. . Training an Intelligent Agent . We will be working in Python, using Keras/Tensorflow as our backbone as well as a reinforcement learning API, Keras-RL. Additionally, to simplify the creation of an environment we will be leveraging OpenAI Gym 1 which presents many simple environments with states, steps, actions, rewards and such already integrated. . 0. Getting Things Ready . First, we need to install any dependencies that we may not already have. . #!pip install numpy #!pip install gym #!pip install pygame #!pip install tensorflow==2.5.0 #!pip install keras #!pip install keras-rl2 #!pip install nnv . . 1. Testing the Environment . We make the necessary imports to get started with the design of our environment. . import gym import random import warnings . . Next, we can start setting up our environment as follows. . env = gym.make(&quot;CartPole-v1&quot;) . For the purpose of this demonstration, I have chosen a simple game as the environment. The CartPole game runs on PyGame, and has the user attempt to balance a leaning pole on a moving cart. . . Let&#39;s learn a bit about our environment. What are the sizes of our state and action spaces? . states = env.observation_space.shape[0] actions = env.action_space.n print(states,actions) . 4 2 . As we can see, our environment has 4 states and 2 possible actions. A bit of digging into the OpenAI Gym documentation and we are able to figure out what these actually are. . . The 4 states are the cart position and velocity, and pole angle and angular velocity. We can see the various boundaries for each of these states in the above tables. For context, the cart position is calculated from the origin and its velocity is the the difference in its position per step. Similarly, the pole angle is measured from the normal to the cart axis and the angular velocity is the change in this angle per step. These 4 states will serve as the input into our policy network. . . Now is probably a good time to mention that a step does not necessarily have to coincide with a unit of real time. As such, velocity in the above states does not involve change per unit time but rather change per step. . . The 2 actions that we can take involve moving the cart in either the positive or negative x direction ([1,0] respectively). These represent the output of our policy network. . Looking into the documentation, the game is bounded by certain rules. We recieve a +1 reward (score) for each step in which the pole is still upright. Upright implies that the pole is within the angle range [-0.2095,0.2095]. The game terminates at a max score of 500, when the pole is no longer upright, or when the cart position exits the limits [-2.4, 2.4] - whichever condition is reached first. . Now, we will attempt to test our environment with a random agent - one which does not have a policy network and makes decisions randomly. . def RandomAgentTest(environment,episodes): total = 0 #Running summation of the score in each game run for episode in range(1, episodes+1): #Run game &#39;episode&#39; number of times state = environment.reset() #reset game environment to the base state done = False #variable holds boolean corresponding to whether game episode is complete or not score = 0 #current episode score, resets to 0 while not done: environment.render() #start our environment action = random.choice([0,1]) #Choose a random action from action space. 1 -&gt; move right, 0 -&gt; move left n_state, reward, done, info = environment.step(action) #Take random action score+=reward #Add reward to cumulative score print(&#39;Episode:{} Score:{}&#39;.format(episode, score)) total = total + score print(&#39;&#39;) print(&#39;Mean score over&#39;,episodes,&#39;episodes --&gt; &#39;,total/episodes) . . RandomAgentTest(env,10) . Episode:1 Score:20.0 Episode:2 Score:14.0 Episode:3 Score:19.0 Episode:4 Score:14.0 Episode:5 Score:17.0 Episode:6 Score:34.0 Episode:7 Score:20.0 Episode:8 Score:43.0 Episode:9 Score:14.0 Episode:10 Score:29.0 Mean score over 10 episodes --&gt; 22.4 . As a frame of reference, this game has a maximum score of 500. As we can see, random actions give a very poor score. . . Now, we will design a policy network for our agent to give it the ability to learn. . 2. Adding Intelligence - Keras NN Model . First, we need to import the necessary resources. . import numpy as np from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Flatten from tensorflow.keras.optimizers import SGD, Adam from rl.agents import DQNAgent from rl.policy import EpsGreedyQPolicy from rl.memory import SequentialMemory . . Our RL model need not be too complex, as the game that is being tackled is relatively simple. We need the input of the network to accept our 4 states, and we need an output of 2 actions. The action with the higher activation at the network&#39;s output is the action that the agent will perform. . For the hidden (inner) layers of the NN, we will have two dense (fully connected) layers. Each layer will have 12 neurons, with ReLU activation between layers (to prevent the layers from collapsing into a linear function). . model = Sequential() model.add(Flatten(input_shape=(1,states))) #&#39;states&#39; variable holds the number of states of the environment (4 inputs) model.add(Dense(12,activation=&#39;relu&#39;)) #dense -&gt; fully connected layer, relu activation between layers. 12 neurons. model.add(Dense(12, activation=&#39;relu&#39;)) model.add(Dense(actions, activation=&#39;linear&#39;)) #&#39;actions&#39; variable holds the number of actions of the environment (2 outputs) model.summary() . Model: &#34;sequential&#34; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten (Flatten) (None, 4) 0 _________________________________________________________________ dense (Dense) (None, 12) 60 _________________________________________________________________ dense_1 (Dense) (None, 12) 156 _________________________________________________________________ dense_2 (Dense) (None, 2) 26 ================================================================= Total params: 242 Trainable params: 242 Non-trainable params: 0 _________________________________________________________________ . For a visual representation of the above NN, we can add the following code. . from nnv import NNV layers = [ {&quot;title&quot;:&quot;input n(states)&quot;, &quot;units&quot;: states, &quot;color&quot;: &quot;darkBlue&quot;,&quot;edges_color&quot;:&quot;red&quot;}, {&quot;title&quot;:&quot;hidden 1 n(relu)&quot;, &quot;units&quot;: 12, &quot;edges_color&quot;:&quot;black&quot;}, {&quot;title&quot;:&quot;hidden 2 n(relu)&quot;, &quot;units&quot;: 12, &quot;edges_color&quot;:&quot;red&quot;}, {&quot;title&quot;:&quot;output n(actions)&quot;, &quot;units&quot;: actions,&quot;color&quot;: &quot;darkBlue&quot;}, ] NNV(layers).render() . . (&lt;Figure size 432x288 with 1 Axes&gt;, &lt;AxesSubplot:&gt;) . 3. Training our Model/Agent . Now that we are at the training stage, we will expain some key topics necessary to having a general understanding of the process. . i) Replay Memory . Replay memory is essentially a catalogue of past states and actions kept when training our agent. Keras-RL provides a convenient class for storing this information, which can be used as follows. . memory = SequentialMemory(limit=50000, window_length=1) . The &#39;limit&#39; hyperparameter specifies the size of memory made available during training. When we surpass 50000 experiences, the oldest will be replaced by the newest. . This begs the question - why do we need memory when training? . When we train our IA, it easy to build sequential correlation between actions and states. In simpler terms, if we train our agent on states as they come with time (sequentially), we run the risk of teaching our agent to perform actions soleley based on time, rather than information recieved from the environment. As such, we sample batches of experiences from our memory at random when training our agent as to break this correlation. . A great analogy here would be a comparison between 2 hypothetical students taking a multiple choice math exam. Student A gets hold of the answer key, and decides to remember the answer to every question based on its number in order. Student B decides to study the content, and learn how to answer each question based on what is asked. Student A here reflects training our agent without memory, relying solely on the sequential order of the questions to know the corresponding answer. Student B understands what each question presents, and represents training with memory. . ii) Policy . Policy in Keras-RL defines the strategy we use to train our NN. We will be using a simple ε-greedy policy which seeks to balance exploration and exploitation. . policy = EpsGreedyQPolicy(eps=0.3) . The &#39;eps&#39; hyperparameter controls the probability of exploration, and therefore eps=0.2 implies a 20% probability of exploration. . Exploration involves the agent taking random actions in its environment, allowing it to find new &#39;paths&#39; of actions that it can take to optimize the reward. . Exploitation involves the agent taking actions with the highest expected reward, allowing it to follow &#39;paths&#39; of actions that yielded greater reward in previous episodes. . iii) Deep Q-Network Agent . We will now put these concepts into play during our training. . agent = DQNAgent(model=model, memory=memory, policy=policy ,nb_actions=actions, nb_steps_warmup=1000) . First, we must create our agent object with references to our model, memory, and policy as seen above. We can define the number of actions that our agent can take through the &#39;nb_actions&#39; parameter. Furthermore, the parameter &#39;nb_steps_warmup&#39; allows us to define how many steps our agent should take before we begin to sample from memory for training. . In terms of our optimizer, we will be using Stochastic Gradient Descent (SGD). SGD is the agorithm responsible for adjusting the weights inside of our neural network, details of which we will not go into. Learning Rate (learning_rate) is a hyperparameter that influences the optimization of our NN weights. For a performance metric, we will use mean squared error (mse). . agent.compile(SGD(learning_rate=1e-3), metrics=[&#39;mse&#39;]) . The next step involves the training of our agent. We will call our .fit() method, which initiates this training. To this method we pass our environment, and give a limit to the number of steps for which we will train. Additionally, we set visualize to False so that our environment is not visible while training, as this would slow down the process. . warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning) warnings.filterwarnings(&quot;ignore&quot;, category=UserWarning) #Suppressing Deprecation &amp; User Warnings agent.fit(env, nb_steps=30000, visualize=False, verbose=1) . Training for 30000 steps ... Interval 1 (0 steps performed) 10000/10000 [==============================] - 70s 7ms/step - reward: 1.0000 179 episodes - episode_reward: 55.531 [9.000, 240.000] - loss: 17.322 - mse: 7884.326 - mean_q: 125.991 Interval 2 (10000 steps performed) 10000/10000 [==============================] - ETA: 0s - reward: 1.000 - 74s 7ms/step - reward: 1.0000 101 episodes - episode_reward: 99.168 [11.000, 327.000] - loss: 18.144 - mse: 7978.776 - mean_q: 126.132 Interval 3 (20000 steps performed) 10000/10000 [==============================] - 74s 7ms/step - reward: 1.0000 done, took 218.268 seconds . &lt;tensorflow.python.keras.callbacks.History at 0x221943ec2b0&gt; . Now that we have our trained agent, we can test our agent&#39;s performance inside of the environment and compare it to our random agent at the beginning of this tutorial. . n_test_episodes = 20 scores = agent.test(env, nb_episodes=n_test_episodes, visualize=0) print(&#39;&#39;) print(&#39;Mean score over&#39;,n_test_episodes,&#39;is &gt; &#39;, np.mean(scores.history[&#39;episode_reward&#39;])) . Testing for 20 episodes ... Episode 1: reward: 227.000, steps: 227 Episode 2: reward: 200.000, steps: 200 Episode 3: reward: 213.000, steps: 213 Episode 4: reward: 196.000, steps: 196 Episode 5: reward: 204.000, steps: 204 Episode 6: reward: 206.000, steps: 206 Episode 7: reward: 204.000, steps: 204 Episode 8: reward: 210.000, steps: 210 Episode 9: reward: 207.000, steps: 207 Episode 10: reward: 210.000, steps: 210 Episode 11: reward: 190.000, steps: 190 Episode 12: reward: 207.000, steps: 207 Episode 13: reward: 225.000, steps: 225 Episode 14: reward: 211.000, steps: 211 Episode 15: reward: 194.000, steps: 194 Episode 16: reward: 193.000, steps: 193 Episode 17: reward: 219.000, steps: 219 Episode 18: reward: 208.000, steps: 208 Episode 19: reward: 200.000, steps: 200 Episode 20: reward: 218.000, steps: 218 Mean score over 20 is &gt; 207.1 . . RandomAgentTest(env,20) . Episode:1 Score:12.0 Episode:2 Score:17.0 Episode:3 Score:20.0 Episode:4 Score:62.0 Episode:5 Score:25.0 Episode:6 Score:17.0 Episode:7 Score:30.0 Episode:8 Score:20.0 Episode:9 Score:19.0 Episode:10 Score:15.0 Episode:11 Score:13.0 Episode:12 Score:26.0 Episode:13 Score:27.0 Episode:14 Score:27.0 Episode:15 Score:48.0 Episode:16 Score:15.0 Episode:17 Score:16.0 Episode:18 Score:81.0 Episode:19 Score:18.0 Episode:20 Score:20.0 Mean score over 20 episodes --&gt; 26.4 . . If we expand the above output cells, we can see that our trained agent averaged a score of 207.1 over 20 episodes, while our random agent averaged 26.4. . We can see how our IA perform on a single run of the game below. . agent.test(env, nb_episodes=1, visualize=1) . Testing for 1 episodes ... Episode 1: reward: 210.000, steps: 210 . &lt;tensorflow.python.keras.callbacks.History at 0x22190bc3e50&gt; . . Note the ability of the agent to keep the pole balanced for a significantly longer period of time when contrasted to the random agent. This difference reflects the fact that we now have an agent with some hint of intellegence. . Wrapping Up . It is with some caution that we can say that our trained agent is now &#39;smart enough&#39; to play this game. . As we can infer, RL has numerous applications that extend from such a simplistic environment and can find usefulness in a large scope of fields. It is a field with diverse reach that finds a place for itself in a modern world concerned with automation. Simple environments like the one presented here can serve as an analogue to more real-world problems. Having given this introduction, I implore the reader to further their knowledge into Reinforcement Learning by going out and seeking new information. . 1. ↩ .",
            "url": "https://de-fellows.github.io/RexCoding/2022/05/31/Reinforcement-Learning.html",
            "relUrl": "/2022/05/31/Reinforcement-Learning.html",
            "date": " • May 31, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://de-fellows.github.io/RexCoding/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://de-fellows.github.io/RexCoding/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://de-fellows.github.io/RexCoding/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://de-fellows.github.io/RexCoding/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}